<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>web进阶之路 | Mylove</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.0/css/all.min.css">
<link rel="shortcut icon" href="https://ww13606467972.github.io/mylove.github.io//favicon.ico?v=1600663153920">
<link rel="stylesheet" href="https://ww13606467972.github.io/mylove.github.io//styles/main.css">





<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="typora-copy-images-to: web进阶之路
file://C:/Users/lenovo/Documents/Gridea/post-images/
前端开发工程师养成手册
一.HTML基础2020.1.28-2020.2..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://ww13606467972.github.io/mylove.github.io/">
        <img src="https://ww13606467972.github.io/mylove.github.io//images/avatar.png?v=1600663153920" class="site-logo">
        <h1 class="site-title">Mylove</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://ww13606467972.github.io/mylove.github.io/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="https://ww13606467972.github.io/mylove.github.io/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="https://ww13606467972.github.io/mylove.github.io/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://ww13606467972.github.io/mylove.github.io//post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/ww13606467972/mylove.github.io" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
          <a class="social-link" href="https://www.zhihu.com/people/wei-ai-zhui-xun-95" target="_blank">
            <i class="fab fa-zhihu"></i>
          </a>
        
      
        
      
        
      
    </div>
    <div class="site-description">
      记录与你在一起的日子
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">巧笑倩兮</a> | <a class="rss" href="https://ww13606467972.github.io/mylove.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">web进阶之路</h2>
            <div class="post-date">2020-05-09</div>
            
            <div class="post-content" v-pre>
              <p>typora-copy-images-to: web进阶之路</p>
<p><code>file://C:/Users/lenovo/Documents/Gridea/post-images/</code></p>
<h1 id="前端开发工程师养成手册">前端开发工程师养成手册</h1>
<h2 id="一html基础2020128-2020213">一.HTML基础2020.1.28-2020.2.13</h2>
<h3 id="1基本标签">1.基本标签</h3>
<h3 id="2表格标签">2.表格标签</h3>
<p>作用：常见显示、展示表格数据，让数据显示的更加规整，可读性非常好。多用于后台数据</p>
<pre><code class="language-html">&lt;table&gt;表格   &lt;tr&gt;行标签  &lt;td&gt;列标签

</code></pre>
<p>width 表格宽度，height表格高度，border表格的边框，bordercolor表格边框的颜色，</p>
<p>cellspacing 单元格与单元格的间距，cellpading 单元格与内容之间的间距</p>
<figure data-type="image" tabindex="1"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1580550252039.png" alt="580550252039" loading="lazy"></figure>
<h4 id="1表头单元格-th">1.表头单元格 th</h4>
<p>表头单元格：第一行；第一列。文本居中并加粗</p>
<h4 id="2表格标题caption">2.表格标题caption</h4>
<figure data-type="image" tabindex="2"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581298171881.png" alt="1581298171881" loading="lazy"></figure>
<h4 id="3合并表格">3.合并表格</h4>
<p><mark>三步走：区分行合并还是列合并；上下左右找到目标单元格；删除多余的单元格。</mark></p>
<h4 id="4表格拓展">4.表格拓展</h4>
<p>表格划分：题头<code>thead</code>、正文<code>tbody</code>、脚注<code>tfoot</code>。</p>
<h3 id="3表单标签">3.表单标签</h3>
<h4 id="31-input控件">3.1 input控件</h4>
<h5 id="311-type属性">3.1.1 	type属性</h5>
<figure data-type="image" tabindex="3"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581479662149.png" alt="1581479662149" loading="lazy"></figure>
<h5 id="312-checked属性">3.1.2 	checked属性</h5>
<p>表示默认选中状态，常见于单选按钮和复选框</p>
<h5 id="313-input属性小结">3.1.3 	input属性小结</h5>
<figure data-type="image" tabindex="4"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581488288962.png" alt="1581488288962" loading="lazy"></figure>
<h4 id="32-label标签理解">3.2 label标签（理解）</h4>
<p>label用于提升用户体验</p>
<p><strong><mark>label使用：</mark></strong></p>
<p><strong>1.label直接包含表单（不推荐）</strong></p>
<p><strong><mark>2.通过for和id来控制</mark></strong></p>
<pre><code class="language-html">&lt;label for=&quot;nc&quot;&gt;昵称&lt;/label&gt;  
&lt;input type=&quot;text&quot; value=&quot;输入文本&quot; id=&quot;nc&quot;&gt;
</code></pre>
<h4 id="33-textarea-控件文本域">3.3 <code>textarea</code> 控件（文本域）</h4>
<p>常用于评论。轻松创建多行输入框</p>
<p>语法：</p>
<pre><code class="language-html">&lt;textarea cols=&quot;每行中的字符数&quot; rows=&quot;显示的行数&quot;&gt;
    文本内容
&lt;/textarea&gt;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581490378338.png" alt="1581490378338" loading="lazy"></figure>
<h4 id="34-select-下拉列表">3.4 select 下拉列表</h4>
<p>语法：</p>
<pre><code class="language-html">&lt;select&gt;
     &lt;option&gt;选项1&lt;/option&gt;
     &lt;option&gt;选项2&lt;/option&gt;
     &lt;option&gt;选项3&lt;/option&gt;
          ....
&lt;/select&gt;
</code></pre>
<p>注意事项：</p>
<p>1.<code>select</code>中至少包含一对option</p>
<p><mark>2.当option 中  selected=“selected” 时，当前选项为默认选中项。</mark></p>
<p>3.不常用，div常用做为下拉列表</p>
<h4 id="35表单域"><mark>3.5表单域</mark></h4>
<figure data-type="image" tabindex="6"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581491036979.png" alt="1581491036979" loading="lazy"></figure>
<h3 id="5图像img标签">5.图像img标签</h3>
<pre><code class="language-HTML">&lt;img src=&quot;图像URL&quot;&gt;&lt;/img&gt;
title提示文本，alt图像不能显示时，显示的文本
</code></pre>
<h3 id="6链接">6.链接</h3>
<figure data-type="image" tabindex="7"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1580870228259.png" alt="1580870228259" loading="lazy"></figure>
<h3 id="7注释标签">7.注释标签</h3>
<pre><code class="language-HTML">&lt;!--这是一个HTML注释--&gt; 
快捷键 Ctrl+/
/*这是一个css注释*/

</code></pre>
<h3 id="8路径">8.路径</h3>
<h4 id="1根目录">1.根目录</h4>
<h4 id="2相对路径">2.相对路径</h4>
<p>以引用文件之网页所在位置为参考，而建立出的目录路径，因此，当保存于不同目录的网页引用同一文件时，所使用的路径将不相同。</p>
<table>
<thead>
<tr>
<th>路径分类</th>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一级路径</td>
<td>无</td>
<td>只需要输入文件名称</td>
</tr>
<tr>
<td>下一级路径</td>
<td>“  / ”</td>
<td>图像位于同级文件夹下</td>
</tr>
<tr>
<td>上一级路径</td>
<td>“  ../  ”</td>
<td><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1580870912047.png" alt="1580870912047" loading="lazy"></td>
</tr>
</tbody>
</table>
<h4 id="3绝对路径">3.绝对路径</h4>
<h3 id="9锚点定位">9.锚点定位</h3>
<figure data-type="image" tabindex="8"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581132755744.png" alt="1581132755744" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581132943655.png" alt="1581132943655" loading="lazy"></figure>
<h3 id="10列表标签">10.列表标签</h3>
<figure data-type="image" tabindex="10"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581389577536.png" alt="1581389577536" loading="lazy"></figure>
<pre><code class="language-html">注意**：&lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;,在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或文字是不允许的
</code></pre>
<h4 id="1有序列表ol">1.有序列表<code>ol</code></h4>
<h4 id="2无序列表ul">2.无序列表<code>ul</code></h4>
<h4 id="3自定义列表">3.自定义列表</h4>
<pre><code class="language-HTML">&lt;dl&gt;
    &lt;dt&gt;名词&lt;/dt&gt;
    &lt;dd&gt;名词解释&lt;/dd&gt;
&lt;/dl&gt;

</code></pre>
<p>举个栗子，小米官网下部<img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581390391450.png" alt="1581390391450" loading="lazy"></p>
<h4 id="4总结">4.总结</h4>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">定义</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><ul></td>
<td style="text-align:center">无序列表</td>
<td style="text-align:center">里面只能包含li,没有顺序，最常用的列表</td>
</tr>
<tr>
<td style="text-align:center"><ol></td>
<td style="text-align:center">有序列表</td>
<td style="text-align:center">里面只能包含li,有顺序</td>
</tr>
<tr>
<td style="text-align:center"><dl></td>
<td style="text-align:center">自定义列表</td>
<td style="text-align:center">里面有两个姐弟，dt和dd</td>
</tr>
</tbody>
</table>
<h2 id="拓展阅读">拓展阅读</h2>
<h3 id="1base标签">1.base标签</h3>
<figure data-type="image" tabindex="11"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581133132763.png" alt="1581133132763" loading="lazy"></figure>
<h3 id="2pre预格式化文本标签">2.pre预格式化文本标签</h3>
<p>pre 写好的文字格式，怎么写怎么显示，少用</p>
<h3 id="3特殊字符">3.特殊字符</h3>
<p>空格<code>&amp;nbsp</code></p>
<figure data-type="image" tabindex="12"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581133528262.png" alt="1581133528262" loading="lazy"></figure>
<h3 id="4xhtml">4.XHTML</h3>
<figure data-type="image" tabindex="13"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581133651779.png" alt="1581133651779" loading="lazy"></figure>
<h3 id="5web标准构成">5.web标准构成</h3>
<p>主要包括结构，表现，行为三个方面。结构用于对网页元素进行整理和分类（HTML），表现用于设置网页元素的版式，主要指css。行为指的是网页模型的定义以及交互的编写，主要是js</p>
<h3 id="6圆角边框">6.圆角边框</h3>
<p>语法</p>
<pre><code class="language-HTML">&lt;style&gt;
    .....
    border-radius:ength;
    .....
&lt;/style&gt;
</code></pre>
<p>●其中每一个值可以为数值或百分比的形式。<br>
●技巧:让一个正方形变成圆圈<code>border-radius:50%</code></p>
<figure data-type="image" tabindex="14"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582437734490.png" alt="1582437734490" loading="lazy"></figure>
<h3 id="7盒子阴影">7.盒子阴影</h3>
<figure data-type="image" tabindex="15"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582437885719.png" alt="1582437885719" loading="lazy"></figure>
<p>语法：</p>
<p>box-shadow:水平阴影 	垂直阴影 	模糊距离(虚实) 	阴影尺寸(影子大小)	阴影颜色	内/外阴影；</p>
<figure data-type="image" tabindex="16"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582437988244.png" alt="1582437988244" loading="lazy"></figure>
<h3 id="8圆角矩形设置4个角">8.圆角矩形设置4个角</h3>
<p>圆角矩形可以为4个角分别设置圆度， 但是是有顺序的</p>
<pre><code>border-top-left-radius:20px;
border-top-right-radius:20px;
border-bottom-right-radius:20px;
border-bottom-left-radius:20px;
</code></pre>
<ul>
<li>
<p>如果4个角，数值相同</p>
<pre><code class="language-css">border-radius: 15px;
</code></pre>
</li>
<li>
<p>里面数值不同，我们也可以按照简写的形式，具体格式如下:</p>
</li>
</ul>
<pre><code class="language-css">border-radius: 左上角 右上角  右下角  左下角;
</code></pre>
<p>还是遵循的顺时针。</p>
<h3 id="9-margin-负值之美">9. margin 负值之美</h3>
<h4 id="1-负边距定位水平垂直居中">1). 负边距+定位：水平垂直居中</h4>
<p>咱们前面讲过， 一个绝对定位的盒子， 利用  父级盒子的 50%，  然后 往左(上) 走 自己宽度的一半 ，可以实现盒子水平垂直居中。</p>
<h4 id="2-压住盒子相邻边框">2). 压住盒子相邻边框</h4>
<h3 id="10-css三角形之美">10 <code>CSS</code>三角形之美</h3>
<pre><code class="language-css"> div {

 	width: 0; 

    height: 0;
    line-height:0；
    font-size: 0;
	border-top: 10px solid red;

	border-right: 10px solid green;

	border-bottom: 10px solid blue;

	border-left: 10px solid #000; 

 }

</code></pre>
<p>一张图， 你就知道 css 三角是怎么来的了, 做法如下：</p>
<figure data-type="image" tabindex="17"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583112104177.png" alt="1583112104177" loading="lazy"></figure>
<ol>
<li>我们用css 边框可以模拟三角效果</li>
<li>宽度高度为0</li>
<li>我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了</li>
<li>为了照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;</li>
</ol>
<h3 id="11-过渡-transition">11. 过渡 transition</h3>
<p>语法格式</p>
<pre><code>transition ： 要过渡的属性  花费时间  运动曲线  何时开始
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583714079273.png" alt="1583714079273" loading="lazy"></figure>
<p>●属性<br>
属性就是你想要变化的css属性，宽度高度 背景颜色内外边距都可以。如果想要所有的属性都变化过渡，写<br>
一个all就可以。<br>
●花费时间<br>
transition-duration花费时间单位是秒(必须写单位) s ms比如0.5s 这个s单位必须写ms毫秒<br>
●运动曲线   默认是ease</p>
<figure data-type="image" tabindex="19"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583714347881.png" alt="1583714347881" loading="lazy"></figure>
<ul>
<li>何时开始  	默认是0s 鼠标触发就开始，可以设置延迟触发时间</li>
</ul>
<h3 id="12-知识点-获得焦点元素">12. 知识点 -获得焦点元素</h3>
<p>:focus 伪类 选择器用于选取获得焦点的元素 。 我们这里主要针对的是 表单元素</p>
<p>:hover</p>
<p>语法：</p>
<pre><code class="language-css">.total input {
  border: 1px solid #ccc;
  height: 30px;
  width: 40px;
  transition: all .5s;
}
/*这个input 获得了焦点*/
.total input:focus {
  width: 80px;
  border: 1px solid skyblue;
}
</code></pre>
<p>border: 1px solid #ccc;<br>
height: 30px;<br>
width: 40px;<br>
transition: all .5s;<br>
}<br>
/<em>这个input 获得了焦点</em>/<br>
.total input:focus {<br>
width: 80px;<br>
border: 1px solid skyblue;<br>
}</p>
<h2 id="二css-进阶之路-2020-213-2020221">二.<code>CSS</code>  进阶之路 2020-2.13-2020.2.21</h2>
<h3 id="21-css三种引入方式">2.1 <code>css</code>三种引入方式</h3>
<h4 id="211-css内部样式表内嵌样式表">2.1.1 <code>css</code>内部样式表（内嵌样式表）</h4>
<pre><code class="language-html">&lt;style type=&quot;text/css&quot;&gt;
&lt;/style&gt;
</code></pre>
<h4 id="212-行内式内联样式">2.1.2 行内式(内联样式)</h4>
<figure data-type="image" tabindex="20"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581565072620.png" alt="1581565072620" loading="lazy"></figure>
<h4 id="213-外部样式表外链式">2.1.3 <mark>外部样式表（外链式）</mark></h4>
<pre><code class="language-html">&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;目标文件的路径及名称&quot;&gt;
&lt;/head&gt;
</code></pre>
<p>可以实现<code>css</code>共享</p>
<h4 id="214-优先级比较">2.1.4 优先级比较</h4>
<p>范围大的优先级小，反而，范围小的优先级高</p>
<h4 id="215-三种样式表总结">2.1.5  三种样式表总结</h4>
<table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>行内样式</td>
<td>书写方便，权重高</td>
<td>较少</td>
<td>控制一个标签（少）</td>
</tr>
<tr>
<td>内部样式</td>
<td>部分结构和样式分离</td>
<td>较多</td>
<td>控制一个页面（中）</td>
</tr>
<tr>
<td>外部样式</td>
<td><strong>完全实现结构和样式的分离</strong></td>
<td>最多，推荐</td>
<td>控制整个站点（多）</td>
</tr>
</tbody>
</table>
<h5 id="团队约定-代码风格"><mark>团队约定-代码风格</mark></h5>
<p>1.展开，竖写</p>
<p>2.推荐小写，不推荐大写</p>
<h3 id="22css-基础选择器">2.2<code>CSS</code>  基础选择器</h3>
<p>选择器来选择标签，把要实现的标签选择出来</p>
<h4 id="221-标签选择器">2.2.1  标签选择器</h4>
<p>概念：指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的css样式</p>
<p>语法</p>
<pre><code class="language-HTML">标签名{
	属性一：属性一值；
	属性二：属性二值；
	.....
}
</code></pre>
<p>作用：标签选择器，可以把某一类标签全部选择出来，比如所有的div标签和所有的span标签</p>
<p>优点：快速为页面中同一类型的标签统一样式。  缺点：不能设计差异化标签</p>
<h4 id="222-id选择器">2.2.2  id选择器</h4>
<p>id选择器用#开头，后面id名</p>
<pre><code class="language-html">#id名{
	属性一：属性值一；
	属性二：属性值二；
	.....
}
&lt;p id=&quot;id名&quot;&gt;
    
&lt;/p&gt;
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581733620451.png" alt="1581733620451" loading="lazy"></figure>
<h4 id="223-class类选择器">2.2.3  <mark>class类选择器</mark></h4>
<p>语法：</p>
<pre><code class="language-html">  .类名{
    属性一：属性一的值；
    属性二：属性二的值；
    .....
  }
  &lt;p class=&quot;类名&quot;&gt;
      
  &lt;/p&gt;
</code></pre>
<p>优点：可以为元素对象定义单独或相同的样式，可以选择一个或多个标签。</p>
<p>多类名</p>
<pre><code class="language-HTML">&lt;P class=&quot;类1 类2&quot;&gt;
    
&lt;/P&gt;
</code></pre>
<h4 id="224-通配符选择器">2.2.4  通配符选择器</h4>
<p>概念： 通配符选择器用==*==号来表示，就是选择所有的标签，  他是所有选择器选择范围最大的，，能匹配页面中所有的元素。</p>
<p>语法：</p>
<pre><code>*{
    属性一:属性一的值；
    属性二：属性二的值；
    ....
}
</code></pre>
<h4 id="225-选择器总结">2.2.5 选择器总结</h4>
<figure data-type="image" tabindex="22"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581831489322.png" alt="1581831489322" loading="lazy"></figure>
<h4 id="226-命名规则">2.2.6  命名规则</h4>
<p><strong>头: header</strong><br>
<strong>内容: content/container</strong><br>
<strong>尾: footer</strong><br>
<strong>导航: nav .</strong><br>
<strong>侧栏: sidebar</strong><br>
<strong>栏目: column</strong><br>
<strong>页面外围控制整体布局宽度: wrapper</strong><br>
<strong>左右中: left right center</strong><br>
<strong>登录条: loginbar</strong><br>
<strong>标志: logo</strong><br>
<strong>广告: banner</strong><br>
<strong>页面主体: main</strong><br>
<strong>热点: hot .</strong><br>
<strong>新闻: news</strong><br>
<strong>下载: download</strong><br>
<strong>子导航: subnav</strong><br>
<strong>菜单: menu .</strong><br>
<strong>子菜单: submenu</strong><br>
<strong>搜索: search</strong></p>
<p><strong>页脚: footer</strong><br>
<strong>版权: copyright</strong><br>
<strong>滚动: scroll</strong><br>
<strong>内容: content</strong><br>
<strong>标签页: tab</strong><br>
<strong>文章列表: list</strong><br>
<strong>提示信息: msg</strong><br>
<strong>小技巧: tips</strong><br>
**栏目标题: title **</p>
<h3 id="23-css字体">2.3 <code>css</code>字体</h3>
<h4 id="231-font-size字体大小">2.3.1  <code>font-size</code>字体大小</h4>
<p>font-size 可以设置字号</p>
<p>单位：可以使用相对长度单位，也可以使用绝对长度单位。推荐<code>px</code>，默认是16<code>px</code>，实际开发中先给body设置16<code>px</code></p>
<figure data-type="image" tabindex="23"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581831837937.png" alt="1581831837937" loading="lazy"></figure>
<h4 id="232-font-family字体">2.3.2  font-family字体</h4>
<p>作用：font-family属性用于设置哪一种字体</p>
<figure data-type="image" tabindex="24"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581833059486.png" alt="1581833059486" loading="lazy"></figure>
<p><mark>注意</mark></p>
<figure data-type="image" tabindex="25"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581833109529.png" alt="1581833109529" loading="lazy"></figure>
<p><strong>Unicode字体</strong></p>
<figure data-type="image" tabindex="26"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581833269998.png" alt="1581833269998" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581833326184.png" alt="1581833326184" loading="lazy"></figure>
<h4 id="233-font-weight-字体粗细">2.3.3  font-weight 字体粗细</h4>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td>默认值（不加粗）</td>
</tr>
<tr>
<td>bold</td>
<td>定义粗体（加粗的）</td>
</tr>
<tr>
<td>100-900</td>
<td>400等于normal。700等于bold。</td>
</tr>
</tbody>
</table>
<h4 id="234-font-style-字体风格">2.3.4  font-style 字体风格</h4>
<figure data-type="image" tabindex="28"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581833763031.png" alt="1581833763031" loading="lazy"></figure>
<h4 id="235-font综合写法">2.3.5 font综合写法</h4>
<p>语法</p>
<pre><code class="language-html">选择器{
	font：font-style  font-weight  font-size/line-height font-family；
}
</code></pre>
<p><mark>注意</mark>：1.必须按照顺序书写，不能更换顺序。各个属性用空格隔开。</p>
<p>​	    2.其中不需要设置的可以省略（取默认值），但必须保留font-size，font-family，否则font属性将不起作用</p>
<h3 id="24-css外观属性">2.4 css外观属性</h3>
<h4 id="241-color文本颜色">2.4.1  color文本颜色</h4>
<figure data-type="image" tabindex="29"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581854674403.png" alt="1581854674403" loading="lazy"></figure>
<p>开发中常用十六进制</p>
<h4 id="242-line-height-行间距">2.4.2  line-height  行间距</h4>
<p>作用：line-height属性用于设置行间距，行与行之间的距离，一般称为行高，常用px</p>
<p>技巧：一般情况下。，行距比字号大7,8像素</p>
<h4 id="243-text-align文本水平对齐方式">2.4.3 text-align：文本水平对齐方式</h4>
<p>作用：text-align 用于设置文本内容的水平对齐方式，相当于HTML中的align</p>
<figure data-type="image" tabindex="30"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581855898239.png" alt="1581855898239" loading="lazy"></figure>
<p><mark>注意：是让盒子内容水平居中，不是让盒子居中对齐</mark></p>
<h4 id="244-text-indent首行缩进">2.4.4 text-indent首行缩进</h4>
<p>作用：可以用于首行设置首行文本的缩进</p>
<p>属性值：使用em作为设置单位</p>
<p>1<code>em</code>就是一个字的宽度，如果是汉字的段落，1<code>em</code>就是一个汉字的宽度</p>
<h4 id="245-text-decoration文本装饰对象是链接">2.4.5  text-decoration文本装饰（对象是链接）</h4>
<figure data-type="image" tabindex="31"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581859103632.png" alt="1581859103632" loading="lazy"></figure>
<h3 id="25-css-复合选择器">2.5 <code>CSS</code> 复合选择器</h3>
<p>目的是更准确更精细的选择目标元素标签，复合选择器是由两个或多个基础选择器，通过不同方式组合而成的</p>
<h4 id="251后代包含选择器">2.5.1后代（包含）选择器</h4>
<p>作用：用于选择元素或元素组的子孙</p>
<p>写法：把外层标签写在前面，内层标签写在后面，中间用<mark>空格</mark>间隔，先写老再写小</p>
<h4 id="252-子元素选择器">2.5.2 子元素选择器</h4>
<p>作用：只能选择作为某元素子元素(<mark>亲儿子</mark>)的元素</p>
<p>写法：父级标签在前，子级标签在后。中间加<code>&gt;</code>连接</p>
<h4 id="253-并集选择器">2.5.3 并集选择器</h4>
<p>应用：某些选择器定义相同的样式，简洁代码，各个选择器通过<code>，</code>连接，通常用于集体声明。</p>
<figure data-type="image" tabindex="32"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581910353409.png" alt="1581910353409" loading="lazy"></figure>
<h4 id="254-链接伪类选择器">2.5.4 链接伪类选择器</h4>
<p>作用： 用于向某些选择器添加特殊效果</p>
<p><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581922116110.png" alt="1581922116110" loading="lazy">    <mark>记忆顺序LVHA</mark></p>
<figure data-type="image" tabindex="33"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581922561313.png" alt="1581922561313" loading="lazy"></figure>
<h4 id="255-交集选择器">2.5.5  交集选择器</h4>
<p>条件：有两个选择器构成，满足标签一、标签二的特点。</p>
<p>举个栗子：</p>
<pre><code class="language-html">&lt;style&gt;
    p.red{
        color:red;
    }
&lt;/style&gt;
&lt;body&gt;
    &lt;p class=&quot;red&quot;&gt;红色&lt;/p&gt;
    &lt;p class=&quot;red&quot;&gt;红色&lt;/p&gt;    
    &lt;p&gt;蓝色&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<h4 id="256-复合选择器总结">2.5.6  复合选择器总结</h4>
<figure data-type="image" tabindex="34"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581922802537.png" alt="1581922802537" loading="lazy"></figure>
<h3 id="26标签显示模式">2.6标签显示模式</h3>
<p>标签显示模式：标签已什么方式进行显示，比如div自占一行，span一行可以多个，分为块元素和行元素。</p>
<h4 id="261-块级元素">2.6.1   块级元素</h4>
<p>div典型的块元素</p>
<p>块级元素的特点：</p>
<p>1.独占一行显示 	2.可以控制高度、宽度、外边距、内边距的大小 	3.宽度默认是父级容器的100%</p>
<p>4.是一个容器或盒子，里面可以放行内或块级元素</p>
<p>注意：只有文字才能组成段落，因此p标签不能放块级元素</p>
<p>​	    还有<code>h1</code>、<code>h2</code>等都是文字类标签，不能放块级元素</p>
<h4 id="262-行内元素">2.6.2 行内元素</h4>
<p>span典型的行内标签</p>
<p>●行内元素的特点:<br>
(1)]相邻行内元素在一 行上, 一行可以显示多个。<br>
(2) 高、宽直接设置是无效的。<br>
(3) 默认宽度就是它本身内容的宽度。<br>
(4) 行内元素只能容纳文本或则其他行内元素。</p>
<h4 id="263-行内块元素">2.6.3  行内块元素</h4>
<p><code>img</code>，<code>input</code>，<code>td</code></p>
<p>行内块元素的特点:<br>
(1)和相邻行内元素(行内块)在一行上,但是之间会有空白缝隙。一行可以显示多个<br>
(2)默认宽度就是它本身内容的宽度。<br>
(3)高度，行高、外边距以及内边距都可以控制。</p>
<h4 id="264-标签显示模式转换">2.6.4  <mark>标签显示模式转换</mark></h4>
<p>●块转行内: <code>display:inline</code>;<br>
●行内转块: <code>display:block</code>;<br>
●块、行内元素转换为行内块: display: inline-block;</p>
<h3 id="27-行高那些事line-height">2.7 行高那些事line-height</h3>
<p>行高和高度的三种关系<br>
●<mark>如果行高等高度文字会垂直居中</mark><br>
●如果行高  大于高度  文字会偏下<br>
●如果行高  小于高度  文字会偏上</p>
<p><mark>文字的行高等于盒子的高度</mark></p>
<h3 id="28-css背景">2.8 <code>css</code>背景</h3>
<h4 id="281-背景颜色-background-color">2.8.1 背景颜色 background-color</h4>
<pre><code>background-color：颜色值；
默认的值是transparent  透明
</code></pre>
<h4 id="282-背景图片-background-image">2.8.2  背景图片 background-image</h4>
<pre><code class="language-html">background-image ：none|url(url)
none 默认无背景图片；
建议URL不加引号
</code></pre>
<h4 id="283-背景平铺-background-repeat">2.8.3 背景平铺 background-repeat</h4>
<pre><code class="language-html">background-repeat：repeat； 默认是平铺
</code></pre>
<p>repeat : 	背景图像在纵向和横向上平铺<br>
no-repeat:	背景图像不平铺<br>
repeat X : 	背景图像在横向上平铺<br>
repeat- y :	背景图像在纵向平铺</p>
<h4 id="284-背景位置-background-position">2.8.4 背景位置  background-position</h4>
<figure data-type="image" tabindex="35"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581988827986.png" alt="1581988827986" loading="lazy"></figure>
<p>●注意:<br>
。必须先指定background-image属性<br>
。position 后面是x坐标和y坐标。可以使用方位名词或者精确单位。<br>
。如果只指定了一个方位名词，另一个值默认居中,为50%。<br>
。如果只指定一个数值那该数值用于x坐标，另一个默认是y坐标，默认居中<br>
。如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left top和top left效果一 致<br>
。如果指定两个值，精确单位和方位名字混合使用,则第一个值是x坐标， 第二个值是y坐标</p>
<h4 id="285-背景附着-background-attachment">2.8.5 背景附着  background-attachment</h4>
<p>背景附着就是解释背景是滚动的还是固定的</p>
<figure data-type="image" tabindex="36"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581992224289.png" alt="1581992224289" loading="lazy"></figure>
<h4 id="286-背景简写">2.8.6  背景简写</h4>
<p><strong>background:背景颜色 背景图片 地址 背景平铺 背景滚动 背景位置;</strong></p>
<h3 id="287背景透明">2.8.7背景透明</h3>
<pre><code class="language-html">background： rgba(0,0,0,0.3);
</code></pre>
<p>● 最后一个参数是alpha透明度取值范围0~1之间<br>
● 我们习惯把0.3的0省略掉这样写<code>background: rgba(0, 0, 0, .3);</code><br>
●注意:背景半透明是指盒子背景半透明， 子里面的内容不受影响<br>
●因为是<code>CSS3</code>，所以低于<code>ie9</code>的版本是不支持的。</p>
<h4 id="289-背景总结">2.8.9 背景总结</h4>
<figure data-type="image" tabindex="37"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1581993969816.png" alt="1581993969816" loading="lazy"></figure>
<h3 id="29-css三大特性">2.9 <code>css</code>三大特性</h3>
<h4 id="291-层叠性">2.9.1  层叠性</h4>
<p>样式冲突，后浪推前浪，遵循就近原则</p>
<h4 id="292继承性">2.9.2继承性</h4>
<p>字标签会继承父标签的部分样式，比如文本颜色和字号</p>
<p>想要设置一个可继承的属性，只需要将它应用于父元素即可</p>
<p>●注意:<br>
。恰当地使用继承可以简化代码，降低<code>CSS</code>样式的复杂性。比如有很多子级孩子都需要某个样式,可以给父<br>
级指定一个,这些孩子继承过来就好了。<br>
。<mark>元素可以继承父元素的样式(text-， font-, line-这些元素开头的可以继承，以及color属性)</mark></p>
<h4 id="293优先级"><mark>2.9.3优先级</mark></h4>
<h5 id="权重计算公式">权重计算公式</h5>
<figure data-type="image" tabindex="38"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582009034473.png" alt="1582009034473" loading="lazy"></figure>
<h5 id="权重叠加">权重叠加</h5>
<p><mark>继承的权重为0</mark></p>
<p>这个不难，但是忽略很容易绕晕。实,我们修改样式，一定要看该标签有没有被选中。<br>
1)如果选中了，那么以上面的公式来计权重。谁大听谁的。<br>
2)如果没有选中， 那么权重是0，因为继承的权重为0.</p>
<h3 id="210盒子模型">2.10盒子模型</h3>
<p>盒子模型有元素的内容、边框(border) 、内边距(padding)、和外边距(margin)组成。<br>
盒子里面的文字和图片等元索是内容区域<br>
盒子的厚度我们成为盒子的边框<br>
盒子内容与边框的距离是内边距(类似单元格的<code>cellpadding</code>)<br>
盒子与盒之间的距离是外边距(类似单元格的<code>cellspacing</code>)</p>
<figure data-type="image" tabindex="39"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582096697034.png" alt="1582096697034" loading="lazy"></figure>
<h4 id="2101-盒子边框">2.10.1 盒子边框</h4>
<h5 id="1语法">1.语法</h5>
<figure data-type="image" tabindex="40"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582097037722.png" alt="1582097037722" loading="lazy"></figure>
<p>●边框的样式:<br>
none: 没有边框即忽略所有边框的宽度(默认值)<br>
solid: 边框为单实线(最为常用的)<br>
dashed: 边框为虚线<br>
dotted: 边框为点线</p>
<h5 id="2-边框的综合写法">2  边框的综合写法</h5>
<p><mark>边框的综合写法</mark>：边框粗细  	边框样式	边框颜色</p>
<figure data-type="image" tabindex="41"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582097470235.png" alt="1582097470235" loading="lazy"></figure>
<h5 id="3-表格的细线边框">3  表格的细线边框</h5>
<p>通过表格的<code>cellspacing= &quot;0&quot;</code>，将单元格与单元格之间的距离设置为0,但是两个单元格之间的边框会出现重叠，从而使边框变粗 解决办法：</p>
<figure data-type="image" tabindex="42"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582098786352.png" alt="1582098786352" loading="lazy"></figure>
<p>collapse：合并<br>
<code>border-collapse:collapse;</code> 表示相邻边框合并在一起。</p>
<h4 id="2102-内边距-padding">2.10.2 内边距 padding</h4>
<figure data-type="image" tabindex="43"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582179847285.png" alt="1582179847285" loading="lazy"></figure>
<figure data-type="image" tabindex="44"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582179898471.png" alt="1582179898471" loading="lazy"></figure>
<p>简写：</p>
<figure data-type="image" tabindex="45"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582180274361.png" alt="1582180274361" loading="lazy"></figure>
<p><mark>开发中注意事项：</mark></p>
<p><mark>padding一定是有的，会增加父盒子的宽度，通过改变内容宽度解决。</mark></p>
<p>padding不影响盒子情况：如果盒子没有宽度，则padding不会撑开盒子</p>
<h4 id="2103外边距-margin">2.10.3外边距 margin</h4>
<h5 id="1margin-盒子与盒子之间-的距离">1.margin ：盒子与盒子之间 的距离</h5>
<figure data-type="image" tabindex="46"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582265618817.png" alt="1582265618817" loading="lazy"></figure>
<h5 id="2块级盒子水平居中"><mark>2.块级盒子水平居中</mark></h5>
<p>●可以让一 个块级盒子实现水平居中必须:<br>
。盒子必须指定了宽度(width)<br>
。然后就给左右的外边距都设置为auto</p>
<figure data-type="image" tabindex="47"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582265775961.png" alt="1582265775961" loading="lazy"></figure>
<h5 id="3插入图片和背景图片">3插入图片和背景图片</h5>
<p>1.插入图片我们用的最多比如产品展示类移动位置只能靠盒模型padding margin<br>
2.背景图片我们一般用于小图标背景或者超大背景图片背景图片只能通过background-position</p>
<h5 id="5外边距合并">5.外边距合并</h5>
<h6 id="1相邻块元素垂直外边距的合并">（1）相邻块元素垂直外边距的合并</h6>
<p>●当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom<br>
●下面的元素有上外边距margin-top,则他们之间的垂直间距不是margin-bottom与margin-top之和<br>
●取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并(也称外边距塌陷)。</p>
<p>解决方案：尽量只给一个盒子添加margin</p>
<h6 id="2嵌套块元素垂直外边距的合并">（2）嵌套块元素垂直外边距的合并</h6>
<figure data-type="image" tabindex="48"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582356982664.png" alt="1582356982664" loading="lazy"></figure>
<p>解决方案:<br>
1.可以为父元素定义上边框。<br>
2.可以为父元素定义上内边距<br>
3.可以为父元素添加overflow:hidden。</p>
<h4 id="2104盒子模型布局稳定性">2.10.4盒子模型布局稳定性</h4>
<p><mark>按照优先使用宽度(width)其次使用内边距(padding)再次外边距(margin)。</mark></p>
<h3 id="211浮动-float">2.11浮动  float</h3>
<p>布局的三种机制：</p>
<p>CSS提供了3种机制来设置盒子的摆放位置，分别是普通流 (标准流)、浮动和定位，其中:<br>
1.普通流(标准流)<br>
块级元素会独占一行，从向下顺序排列;<br>
■常用元素: div、hr、 p、h1~h6、 ul、 ol、 dI、 form、 table<br>
行内元素会按照顺序,从左到右顺序排列，碰到父元素边缘则自动换行;<br>
■常用元素: span、a、i、 em等<br>
2.浮动<br>
让盒子从普通流中浮起来，主要作用让多个块级盒子一行显示。<br>
3.定位<br>
将盒子定在浏览器的某一 个位置-- -<code>CSS</code>离不开定位，特别是后面的<code>js</code>特效。</p>
<p>网页布局的核心：用css摆放盒子</p>
<h4 id="1float语法">1.float语法</h4>
<figure data-type="image" tabindex="49"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582508242993.png" alt="1582508242993" loading="lazy"></figure>
<hr>
<p><strong>浮动口诀：浮</strong></p>
<figure data-type="image" tabindex="50"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582509001943.png" alt="1582509001943" loading="lazy"></figure>
<p><strong>浮动口诀：漏</strong></p>
<p>浮动一-漏<sub>漏</sub>漏~浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准<br>
流的，我们俗称“脱标”。</p>
<p><strong>浮动口诀：特</strong></p>
<p>浮动 特性float属性会改变元素display属性。<br>
任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元索。生成的块级框和我们前面的行内<br>
块极其相似。</p>
<hr>
<h4 id="2浮动元素与父盒子的关系">2.浮动元素与父盒子的关系</h4>
<p>子盒子的浮动参照父盒子对齐<br>
不会与父盒子的边框重委，也不会超过父盒子的内边距</p>
<figure data-type="image" tabindex="51"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582596900141.png" alt="1582596900141" loading="lazy"></figure>
<h4 id="3浮动元素与兄弟盒子的关系">3.浮动元素与兄弟盒子的关系</h4>
<p>在一个父级盒子中，如果前一个兄弟盒子是:<br>
●<strong>浮动</strong>的，那么当前盒子会与前一个盒子的顶部对齐;<br>
●普通流的,那么当前盒子会显示在前一个兄弟盒子的下方。</p>
<p><mark>浮动只会影响当前的或者 是后面的盒子,不会影响前面的标准流</mark></p>
<hr>
<figure data-type="image" tabindex="52"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582597310112.png" alt="1582597310112" loading="lazy"></figure>
<figure data-type="image" tabindex="53"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582597356396.png" alt="1582597356396" loading="lazy"></figure>
<hr>
<h4 id="4清除浮动">4.清除浮动</h4>
<figure data-type="image" tabindex="54"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582598473452.png" alt="1582598473452" loading="lazy"></figure>
<figure data-type="image" tabindex="55"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582599018177.png" alt="1582599018177" loading="lazy"></figure>
<p>解决办法：</p>
<p><mark>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0的问题。清除浮动之后，父级就会根据浮<br>
动的子盒子自动检测高度。父级有了高度,就不会影响下面的标准流了</mark></p>
<figure data-type="image" tabindex="56"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582599509767.png" alt="1582599509767" loading="lazy"></figure>
<p>开发中常用<code>clear:both</code></p>
<h5 id="1额外标签法隔墙法">1.额外标签法（隔墙法）</h5>
<figure data-type="image" tabindex="57"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582599781923.png" alt="1582599781923" loading="lazy"></figure>
<h5 id="2父级添加overflow属性">2.父级添加overflow属性</h5>
<figure data-type="image" tabindex="58"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582599812006.png" alt="1582599812006" loading="lazy"></figure>
<h5 id="3使用after伪元素">3.使用after伪元素</h5>
<p><mark>:after  方式为空元素额外标签法的升级版，好处是不用单独加标签了</mark></p>
<pre><code class="language-html">.clearfix:after {
	content: &quot;&quot;;
	display: block;
	height: 0;
	clear: both;
	visibility: hidden;
}
.clearfix {
	*zoom: 1;
}
父级盒子调用样式clearfix
</code></pre>
<figure data-type="image" tabindex="59"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582681244236.png" alt="1582681244236" loading="lazy"></figure>
<h5 id="4使用双伪元素">4.使用双伪元素</h5>
<pre><code>.clearfix:before,
.clearfix:after {
    content: &quot;&quot;;
    display: table;
    
}
.clearfix: after {
    clear: both;
    
}
.clearfix {
    *zoom: 1
}
</code></pre>
<p>.clearfix:before,<br>
.clearfix:after {<br>
content: &quot;&quot;;<br>
display: table;<br>
}<br>
.clearfix:after {<br>
clear: both;<br>
}</p>
<h4 id="5清除浮动总结">5清除浮动总结</h4>
<figure data-type="image" tabindex="60"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582681696880.png" alt="1582681696880" loading="lazy"></figure>
<h3 id="212-photoshop-切图">2.12 <code>Photoshop</code> 切图</h3>
<p>常见的图片格式：</p>
<ol>
<li>
<p><code>jpg</code>图像格式:<br>
<code>JPEG (.JPG</code>) 对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用<code>jpg</code>格式的</p>
</li>
<li>
<p><code>gif</code>图像格式:<br>
<code>GIF</code>格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果</p>
</li>
<li>
<p>png图像格式<br>
是一种新兴的网络图形格式，结合了<code>GIF</code>和<code>JPEG</code>的优点，具有存储形式丰富的特点，能够保持透明背景</p>
</li>
<li>
<p><code>PSD</code>图像格式<br>
<code>PSD</code>格式是<code>Photoshop</code>的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿。</p>
</li>
</ol>
<p>切片方法</p>
<figure data-type="image" tabindex="61"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582683292906.png" alt="1582683292906" loading="lazy"></figure>
<h3 id="213-定位position">2.13 定位position</h3>
<p>CSS提供了3种机制来设置盒子的摆放位置，分别是普通流、 浮动和定位,其中:<br>
1.普通流(<strong>标准流</strong>]<br>
2.浮动<br>
。让盒子从普通流中浮起来-- 让多个舒(div)水平排列成-行。<br>
3.定位<br>
。将盒子定在某一个位置自由的漂浮在其他盒子的上面-一 CSS离不开定位,特别是后面的js特效。</p>
<p><mark>标准流在最底层(海底)          浮动的盒子在中间层(海面)       -定位的盒子在最上层(天空)</mark></p>
<h4 id="1定位概念">1.定位概念</h4>
<p><code>定位=定位模式+边偏移</code></p>
<figure data-type="image" tabindex="62"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582854335830.png" alt="1582854335830" loading="lazy"></figure>
<h4 id="2定位模式">2.定位模式</h4>
<figure data-type="image" tabindex="63"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582854483777.png" alt="1582854483777" loading="lazy"></figure>
<h5 id="21-静态定位-static">2.1 静态定位 static</h5>
<p>静态定位是元素的默认定位方式，无定位的意思。它相当于border里面的none，不要定位的时候用。<br>
静态定位按照标准流特性摆放位置，它没有边偏移。<br>
静态定位在布局时我们几乎不用的</p>
<h5 id="22-相对定位-relative">2.2 相对定位 relative</h5>
<p>相对定位是元素相对于它 原来在标准流中的位置来说的</p>
<p><mark>相对定位的特点: (务必记住)</mark><br>
<mark>●相对于自己原来在标准流中位置来移动的</mark><br>
<mark>●原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。</mark></p>
<figure data-type="image" tabindex="64"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582855268374.png" alt="1582855268374" loading="lazy"></figure>
<h5 id="23-绝对定位-absolute">2.3 绝对定位 absolute</h5>
<p>绝对定位是元素以带有定位的父级元素来移动位置(拼爹型)<br>
1.完全脱标-- 完全不占位置;<br>
<mark>2.若父元素没有定位，则以浏览器为准定位(Document 文档)</mark></p>
<figure data-type="image" tabindex="65"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582855757503.png" alt="1582855757503" loading="lazy"></figure>
<figure data-type="image" tabindex="66"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582855736885.png" alt="1582855736885" loading="lazy"></figure>
<p>口诀：<mark>子绝父相</mark></p>
<h5 id="24-固定定位-fixed">2.4 固定定位 fixed</h5>
<p>定定位是绝对定位的一种特殊形式: (认死理型) 如果说绝对定位是一 个矩形那么固定走位就类似于正方形<br>
1.完全脱标- -- 完全不占位置;<br>
2.只认浏览器的可视窗口----<code>浏览器可视窗口 +边偏移属性</code>来设置元素的位置;<br>
。跟父元素没有任何关系;<br>
。<mark>不随滚动条滚动</mark>。</p>
<h4 id="3-定位-扩展">3 定位 扩展</h4>
<h5 id="31-绝对定位的盒子居中">3.1 绝对定位的盒子居中</h5>
<p><mark>绝对定位/固定定位的盒子。不能通过设置<code>margin：0 auto</code>；来设置水平居中的</mark></p>
<p>解决办法：</p>
<figure data-type="image" tabindex="67"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582939928211.png" alt="1582939928211" loading="lazy"></figure>
<h5 id="32-堆叠顺序z-index">3.2 堆叠顺序（z-index）</h5>
<p>在使用<strong>定位</strong>布局时，可能会<strong>出现盒子重叠的情况</strong>。</p>
<p>加了定位的盒子，默认<strong>后来者居上</strong>， 后面的盒子会压住前面的盒子。</p>
<p>应用 <code>z-index</code> 层叠等级属性可以<strong>调整盒子的堆叠顺序</strong>。如下图所示：</p>
<figure data-type="image" tabindex="68"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582940630520.png" alt="1582940630520" loading="lazy"></figure>
<p><code>z-index</code> 的特性如下：</p>
<ol>
<li><strong>属性值</strong>：<strong>正整数</strong>、<strong>负整数</strong>或 <strong>0</strong>，默认值是 0，数值越大，盒子越靠上；</li>
<li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li>
<li><strong>数字后面不能加单位</strong>。</li>
</ol>
<p><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</p>
<h5 id="33-定位改变display属性">3.3 定位改变display属性</h5>
<p>display 是 显示模式， 可以改变显示模式有以下方式:</p>
<ul>
<li>可以用inline-block  转换为行内块</li>
<li>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</li>
<li>绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。</li>
</ul>
<p>一个行内的盒子，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，不用转换，就可以给这个盒子直接设置宽度和高度等。</p>
<p>浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的），给<mark>盒子改为了浮动或者定位，就不会有垂直外边距合并的问题</mark>了。</p>
<h4 id="4定位总结">4.定位总结</h4>
<table>
<thead>
<tr>
<th>定位模式</th>
<th>是否脱标占有位置</th>
<th style="text-align:left">移动位置基准</th>
<th>模式转换（行内块）</th>
<th>使用情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态static</td>
<td>不脱标，正常模式</td>
<td style="text-align:left">正常模式</td>
<td>不能</td>
<td>几乎不用</td>
</tr>
<tr>
<td><mark>相对定位relative</mark></td>
<td>不脱标，占有位置</td>
<td style="text-align:left">相对自身位置移动</td>
<td>不能</td>
<td>基本单独使用</td>
</tr>
<tr>
<td><mark>绝对定位absolute</mark></td>
<td>完全脱标，不占有位置</td>
<td style="text-align:left">相对于定位父级移动位置</td>
<td>能</td>
<td>要和定位父级元素搭配使用</td>
</tr>
<tr>
<td><mark>固定定位fixed</mark></td>
<td>完全脱标，不占有位置</td>
<td style="text-align:left">相对于浏览器移动位置</td>
<td>能</td>
<td>单独使用，不需要父级</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：</p>
<ol>
<li><strong>边偏移</strong>需要和<strong>定位模式</strong>联合使用，<strong>单独使用无效</strong>；</li>
<li><code>top</code> 和 <code>bottom</code> 不要同时使用；</li>
<li><code>left</code> 和 <code>right</code> 不要同时使用。</li>
</ol>
<h2 id="三-css高级技巧-2020222-202031">三. <code>CSS</code>高级技巧 2020.2.22-2020.3.1</h2>
<h3 id="1元素的显示与隐藏">1.元素的显示与隐藏</h3>
<ul>
<li>
<p>目的</p>
<p>让一个元素在页面中消失或者显示出来</p>
</li>
<li>
<p>场景</p>
<p>类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！</p>
</li>
</ul>
<h4 id="11-display-显示重点">1.1 display 显示（重点）</h4>
<ul>
<li>
<p>display 设置或检索对象是否及如何显示。</p>
<pre><code>display: none 隐藏对象

display：block 除了转换为块级元素之外，同时还有显示元素的意思。
</code></pre>
</li>
<li>
<p>特点： 隐藏之后，不再保留位置。</p>
</li>
</ul>
<figure data-type="image" tabindex="69"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583030764310.png" alt="1583030764310" loading="lazy"></figure>
<p>实际开发场景：</p>
<blockquote>
<p>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</p>
</blockquote>
<h4 id="12-visibility-可见性了解">1.2 visibility 可见性（了解）</h4>
<ul>
<li>
<p>设置或检索是否显示对象。</p>
<pre><code>visibility：visible ; 　//对象可视

visibility：hidden; 　  //对象隐藏
</code></pre>
</li>
<li>
<p>特点： 隐藏之后，继续保留原有位置。（停职留薪）</p>
</li>
</ul>
<h4 id="13-overflow-溢出重点">1.3 overflow 溢出(重点)</h4>
<ul>
<li>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>visible</strong></td>
<td>不剪切内容也不添加滚动条</td>
</tr>
<tr>
<td><strong>hidden</strong></td>
<td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td>
</tr>
<tr>
<td><strong>scroll</strong></td>
<td>不管超出内容否，总是显示滚动条</td>
</tr>
<tr>
<td><strong>auto</strong></td>
<td>超出自动显示滚动条，不超出不显示滚动条</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="70"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583031276487.png" alt="1583031276487" loading="lazy"></figure>
<p>实际开发场景：</p>
<ol>
<li>清除浮动</li>
<li>隐藏超出内容，隐藏掉,  不允许内容超过父盒子。</li>
</ol>
<h4 id="14-显示与隐藏总结">1.4 显示与隐藏总结</h4>
<table>
<thead>
<tr>
<th>属性</th>
<th>区别</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>display</strong></td>
<td>隐藏对象，不保留位置</td>
<td>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</td>
</tr>
<tr>
<td><strong>visibility</strong></td>
<td>隐藏对象，保留位置</td>
<td>使用较少</td>
</tr>
<tr>
<td><strong>overflow</strong></td>
<td>只是隐藏超出大小的部分</td>
<td>1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围</td>
</tr>
</tbody>
</table>
<h3 id="2-css用户界面样式">2.  CSS用户界面样式</h3>
<ul>
<li>所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。
<ul>
<li>更改用户的鼠标样式 (滚动条因为兼容性非常差，我们不研究)</li>
<li>表单轮廓等。</li>
<li>防止表单域拖拽</li>
</ul>
</li>
</ul>
<h4 id="21-鼠标样式cursor">2.1 鼠标样式cursor</h4>
<p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>default</strong></td>
<td>小白  默认</td>
</tr>
<tr>
<td><strong>pointer</strong></td>
<td>小手</td>
</tr>
<tr>
<td><strong>move</strong></td>
<td>移动</td>
</tr>
<tr>
<td><strong>text</strong></td>
<td>文本</td>
</tr>
<tr>
<td><strong>not-allowed</strong></td>
<td>禁止</td>
</tr>
</tbody>
</table>
<h4 id="22-轮廓线-outline">2.2 轮廓线 outline</h4>
<img src="G:/BaiduNetdiskDownload/01-03%20%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/02-CSS%E8%B5%84%E6%96%99/02-CSS%E8%B5%84%E6%96%99/CSS-Day07/%E7%AC%94%E8%AE%B0/media/outline.png">
<p>是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p>
<pre><code class="language-css"> outline : outline-color ||outline-style || outline-width 
</code></pre>
<p>但是我们都不关心可以设置多少，我们平时都是去掉的。 li</p>
<p>最直接的写法是 ：  outline: 0;   或者  outline: none;</p>
<pre><code class="language-html"> &lt;input  type=&quot;text&quot;  style=&quot;outline: 0;&quot;/&gt;
</code></pre>
<h4 id="23-防止拖拽文本域resize">2.3 防止拖拽文本域resize</h4>
<p>实际开发中，我们文本域右下角是不可以拖拽：</p>
<pre><code class="language-html">&lt;textarea  style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt;
</code></pre>
<h4 id="24-用户界面样式总结">2.4 用户界面样式总结</h4>
<table>
<thead>
<tr>
<th>属性</th>
<th>用途</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>鼠标样式</strong></td>
<td>更改鼠标样式cursor</td>
<td>样式很多，重点记住 pointer</td>
</tr>
<tr>
<td><strong>轮廓线</strong></td>
<td>表单默认outline</td>
<td>outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用</td>
</tr>
<tr>
<td>防止拖拽</td>
<td>主要针对文本域resize</td>
<td>防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none</td>
</tr>
</tbody>
</table>
<h3 id="3-vertical-align-垂直对齐">3. vertical-align 垂直对齐</h3>
<ul>
<li>有宽度的块级元素居中对齐，是margin: 0 auto;</li>
<li>让文字居中对齐，是 text-align: center;</li>
</ul>
<p>但是我们从来没有讲过有垂直居中的属性。</p>
<p>vertical-align 垂直对齐，它只针对于==<strong>行内元素</strong>或者<strong>行内块元素</strong>==，</p>
<figure data-type="image" tabindex="71"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583049726596.png" alt="1583049726596" loading="lazy"></figure>
<pre><code class="language-css">vertical-align : baseline |top |middle |bottom 
</code></pre>
<p>设置或检索对象内容的垂直对其方式。</p>
<ul>
<li>
<p>注意：</p>
<p>vertical-align 不影响块级元素中的内容对齐，它只针对于<strong>行内元素</strong>或者<strong>行内块元素</strong>，</p>
<p>特别是行内块元素， <strong>通常用来控制图片/表单与文字的对齐</strong>。</p>
<h4 id="31-图片表单和文字对齐">3.1 图片表单和文字对齐</h4>
</li>
</ul>
<figure data-type="image" tabindex="72"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583049978894.png" alt="1583049978894" loading="lazy"></figure>
<h4 id="32-去除图片底侧空白缝隙">3.2 去除图片底侧空白缝隙</h4>
<ul>
<li>
<p>原因：</p>
<p>图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。</p>
<p>就是图片底侧会有一个空白缝隙。</p>
</li>
<li>
<p>解决的方法就是：</p>
<ul>
<li>给img vertical-align:middle | top| bottom等等。  让图片不要和基线对齐。</li>
<li>给img 添加 display：block; 转换为块级元素就不会存在问题了。</li>
</ul>
</li>
</ul>
<h3 id="4溢出的文字省略号显示">4.溢出的文字省略号显示</h3>
<h4 id="41-white-space">4.1 white-space</h4>
<ul>
<li>white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容</li>
</ul>
<pre><code>white-space:normal ；默认处理方式

white-space:nowrap ；　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。
</code></pre>
<h4 id="42-text-overflow-文字溢出">4.2 text-overflow 文字溢出</h4>
<ul>
<li>设置或检索是否使用一个省略标记（...）标示对象内文本的溢出</li>
</ul>
<pre><code>text-overflow : clip ；不显示省略标记（...），而是简单的裁切 

text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...）
</code></pre>
<p><strong>注意</strong>：</p>
<p>一定要首先强制一行内显示，再次和overflow属性  搭配使用</p>
<h4 id="43-总结-三部曲">4.3 总结-三部曲</h4>
<figure data-type="image" tabindex="73"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583051941436.png" alt="1583051941436" loading="lazy"></figure>
<h3 id="5-css精灵技术">5. css精灵技术</h3>
<h4 id="51为什么需要精灵技术">5.1为什么需要精灵技术</h4>
<figure data-type="image" tabindex="74"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583053952954.png" alt="1583053952954" loading="lazy"></figure>
<p>图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。</p>
<p>然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。</p>
<p><strong>为什么需要精灵技术：</strong></p>
<blockquote>
<p><strong>为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。</strong></p>
</blockquote>
<p>出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。</p>
<h4 id="52-精灵技术详解">5.2 精灵技术详解</h4>
<p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。</p>
<figure data-type="image" tabindex="75"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583054026900.png" alt="1583054026900" loading="lazy"></figure>
<p>这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。</p>
<p>我们需要使用CSS的</p>
<ul>
<li>background-image、</li>
<li>background-repeat</li>
<li>background-position属性进行背景定位，</li>
<li>其中最关键的是使用background-position 属性精确地定位。</li>
</ul>
<h4 id="53-精灵技术使用的核心总结">5.3 精灵技术使用的核心总结</h4>
<p>首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。</p>
<ol>
<li>精确测量，每个小背景图片的大小和 位置。</li>
<li>给盒子指定小背景图片时， 背景定位基本都是 负值。</li>
</ol>
<h4 id="54-制作精灵图">5.4 制作精灵图</h4>
<p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。</p>
<p>大部分情况下，精灵图都是网页美工做。</p>
<pre><code>我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。
我们可以横向摆放也可以纵向摆放，但是每个图片之间留有适当的空隙
在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。
</code></pre>
<p>结束语：   小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。</p>
<h3 id="6导航栏-滑动门">6.导航栏-滑动门</h3>
<p>为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。</p>
<p>http://weixin.qq.com/</p>
<h4 id="61-核心技术">6.1  核心技术</h4>
<p>核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。</p>
<p>一般的经典布局都是这样的：</p>
<pre><code class="language-html">&lt;li&gt;
  &lt;a href=&quot;#&quot;&gt;
    &lt;span&gt;导航栏内容&lt;/span&gt;
  &lt;/a&gt;
&lt;/li&gt;
</code></pre>
<p>css样式</p>
<pre><code class="language-css">* {
      padding:0;
      margin:0;

    }
    body{
      background: url(images/wx.jpg) repeat-x;
    }
    .father {
      padding-top:20px;
    }
    li {
      padding-left: 16px;
      height: 33px;
      float: left;
      line-height: 33px;
      margin:0  10px;
      background: url(./images/to.png) no-repeat left ;
    }
    a {
      padding-right: 16px;
      height: 33px;
      display: inline-block;
      color:#fff;
      background: url(./images/to.png) no-repeat right ;
      text-decoration: none;
    }
    li:hover,
     li:hover a {
      background-image:url(./images/ao.png);
    }
</code></pre>
<p>总结：</p>
<ol>
<li>
<p>a 设置 背景左侧，padding撑开合适宽度。</p>
</li>
<li>
<p>span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。</p>
</li>
<li>
<p>之所以a包含span就是因为 整个导航都是可以点击的。</p>
</li>
</ol>
<h2 id="四-h5css3-2020331-202045">四. <code>H5</code>+<code>CSS3</code>  2020.3.31-2020.4.5</h2>
<h3 id="1-属性选择器">1. 属性选择器</h3>
<figure data-type="image" tabindex="76"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1585739228397.png" alt="1585739228397" loading="lazy"></figure>
<p><mark>类选择器、属性选择器、伪类选择器，权重为10</mark></p>
<h3 id="2-css3结构伪类选择器">2. css3结构伪类选择器</h3>
<figure data-type="image" tabindex="77"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1585801226823.png" alt="1585801226823" loading="lazy"></figure>
<figure data-type="image" tabindex="78"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1585802068760.png" alt="1585802068760" loading="lazy"></figure>
<figure data-type="image" tabindex="79"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1585802035239.png" alt="1585802035239" loading="lazy"></figure>
<h3 id="3-伪元素选择器">3. 伪元素选择器</h3>
<figure data-type="image" tabindex="80"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1585810045679.png" alt="1585810045679" loading="lazy"></figure>
<figure data-type="image" tabindex="81"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1585810355086.png" alt="1585810355086" loading="lazy"></figure>
<h3 id="4-css3-2d转换">4. <code>css3</code> <code>2D</code>转换</h3>
<h4 id="41-移动translate">4.1  移动translate</h4>
<figure data-type="image" tabindex="82"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1585833985380.png" alt="1585833985380" loading="lazy"></figure>
<figure data-type="image" tabindex="83"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1585833993976.png" alt="1585833993976" loading="lazy"></figure>
<h4 id="42-旋转-rotate">4.2  旋转 rotate</h4>
<p>语法：</p>
<pre><code class="language-html">transform:rotate(度数)
</code></pre>
<p>重点：</p>
<p>●rotate里面跟度数，单位是deg比如rotate(45<code>deg</code>)<br>
●角度为正时,顺时针,负时,为逆时针<br>
●默认旋转的中心点是元素的中心点</p>
<h4 id="43-缩放-scale">4.3 缩放  scale</h4>
<pre><code>transform：scale(x，y)
</code></pre>
<figure data-type="image" tabindex="84"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586133051810.png" alt="1586133051810" loading="lazy"></figure>
<h4 id="44-综合写法">4.4 综合写法</h4>
<figure data-type="image" tabindex="85"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586133117559.png" alt="1586133117559" loading="lazy"></figure>
<h3 id="5-动画-animation">5. 动画 animation</h3>
<h4 id="51-动画的基本使用">5.1 动画的基本使用</h4>
<ol>
<li>
<p>定义动画</p>
<pre><code class="language-css">@keyframs 动画名称 {
    0%{
        width:100px；
    }
    100% {
        width:200px；
	}

}
</code></pre>
<figure data-type="image" tabindex="86"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586133426781.png" alt="1586133426781" loading="lazy"></figure>
</li>
<li>
<p>调用动画</p>
<pre><code class="language-html">animation-name:动画名称；
animation-duration：持续时间；
</code></pre>
</li>
</ol>
<h4 id="52-动画常用属性">5.2  动画常用属性</h4>
<figure data-type="image" tabindex="87"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586136170868.png" alt="1586136170868" loading="lazy"></figure>
<h4 id="53-动画简写">5.3 动画简写</h4>
<p>animation：动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向  动画起始或者结束的状态</p>
<figure data-type="image" tabindex="88"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586136678453.png" alt="1586136678453" loading="lazy"></figure>
<h4 id="54-速度曲线调节">5.4 速度曲线调节</h4>
<p>animation-timing-function:规定动画的速度曲线，默认是‘’ease''</p>
<figure data-type="image" tabindex="89"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586158975573.png" alt="1586158975573" loading="lazy"></figure>
<h3 id="6-3d-转换">6. <code>3D</code> 转换</h3>
<h4 id="61-3d-移动-translate3d">6.1 <code>3D</code> 移动  <code>translate3d</code></h4>
<figure data-type="image" tabindex="90"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586225110398.png" alt="1586225110398" loading="lazy"></figure>
<h4 id="62-透视-perspective">6.2 透视  perspective</h4>
<figure data-type="image" tabindex="91"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586225567852.png" alt="1586225567852" loading="lazy"></figure>
<figure data-type="image" tabindex="92"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586225683724.png" alt="1586225683724" loading="lazy"></figure>
<p>规律：<mark>近大远小</mark></p>
<figure data-type="image" tabindex="93"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586226538510.png" alt="1586226538510" loading="lazy"></figure>
<h4 id="63-3d旋转-rotate3d">6.3 <code>3D</code>旋转 <code>rotate3d</code></h4>
<figure data-type="image" tabindex="94"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586226602343.png" alt="1586226602343" loading="lazy"></figure>
<h4 id="64-3d呈现transform-style">6.4 3D呈现transform-style</h4>
<p>●控制子元素是否开启三维立体环境。。<br>
●<code>transform-style: flat</code>子元素不开启<code>3d</code>立体空间默认的<br>
●<code>transform-style: preserve- 3d;</code>元素开启立体空间<br>
●代码写给父级,但是影响的是子盒子</p>
<h2 id="五-js基础-2020316-2020331">五. <code>JS</code>基础   2020.3.16-2020.3.31</h2>
<h4 id="1-变量">1. 变量</h4>
<p>声明变量的特殊情况</p>
<figure data-type="image" tabindex="95"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1584409109493.png" alt="1584409109493" loading="lazy"></figure>
<h6 id="数据类型的分类">数据类型的分类</h6>
<h5 id="基本数据类型undefined-null-boolean-number-string">基本数据类型：undefined、null、Boolean、number、string</h5>
<h5 id="复杂数据类型object-function">复杂数据类型：object、function</h5>
<h5 id="基本语法">基本语法：</h5>
<h5 id="typeof-检测变量数据类型返回数据类型">typeof 检测变量数据类型，返回数据类型</h5>
<p>扩：undefined类型只有一个值，即特殊的undefined。</p>
<p><mark>null值表示一个空对象指针，undefined值是派生自null值的，所以undefined == null的返回结果是true</mark></p>
<p>number</p>
<p>Number: 表示整数和浮点数      NaN：即非数值(Not a Number)是一个特殊的数值</p>
<p>说明：</p>
<ol>
<li>
<p>任何涉及NaN的操作(例如NaN/10)都会返回NaN</p>
</li>
<li>
<p>NaN与任何值都不相等，包括NaN本身</p>
</li>
</ol>
<p>isNaN()</p>
<p>语法：isNaN(n)</p>
<p>功能：检测n是否是“非数值” 返回值：boolean //true false</p>
<p>参数：参数n可以是任何类型</p>
<p>说明：isNaN()在接收到一个值之后，会尝试将这个值转换为数值<br>
某些不是数值的值会直接转换为数值</p>
<h5 id="parseint-parsefloat">parseInt() parseFloat()</h5>
<p>parseInt()：会忽略字符串前面的空格，直到找到第一个非空格字符。</p>
<p>parseFloat()：从第一个字符开始解析每个字符，直到遇见一个无效的浮点数字符为止</p>
<p><mark>注：如果字符串中包含有效的十六进制格式，parseInt('0xf')将'0x'转换为相同大小的十进制数值，而parseFloat('0xf')只会输出0</mark></p>
<h5 id="string和-tostring-转换成字符串">String()和 toString() 转换成字符串</h5>
<h4 id="2-数组-array">2. 数组 Array</h4>
<p>数组的初始化:</p>
<pre><code class="language-javascript">var arr=new Array(count);//count 填数组元素的多少
var arr=[1,2,3];
var arr=[]; //创建一个空数组
</code></pre>
<h5 id="数组中的方法">数组中的方法</h5>
<ol>
<li>push() 数组的末尾添加新的元素</li>
<li>pop() 删除数组的最后一个元素</li>
<li>unshift() 数组的开头添加新元素</li>
<li>shift() 删除数组开头第一个元素</li>
<li>concat() 合并两个数组</li>
<li>join() 数组转换成字符串，可以添加分隔符</li>
<li>reverse( ) 将数组中的元素翻转</li>
<li>splice() 从数组中选取元素</li>
<li>sort() 数组排序</li>
</ol>
<pre><code class="language-javascript">var arr=[0,5,11,9,7,6,4,21];
var newarr=arr.sort(function(a,b){return a-b}); //a-b 升序    b-a 降序   
console.log(newarr.join());
</code></pre>
<h4 id="函数">函数</h4>
<h5 id="函数的初始化">函数的初始化：</h5>
<pre><code class="language-javascript">function name(形参) {
	....
}
name();
//调用函数
</code></pre>
<pre><code class="language-javascript">// 最大公约数
function getNum(m,n){
	var c;
	while((c=m%n)!=0){
		m=n; // 把除数作为了被除数 18
		n=c; // 把余数作为了除数  6
	}
	return n; 
}
// alert(getNum(9,27))

//最小公倍数16 12   16*12/4
var c;
function Num(m,n) {
	c=(m*n)/getNum(m,n);
	return c;
}
alert(getNum(16,12));
alert(Num(16,12));
</code></pre>
<pre><code class="language-javascript"> //质数：只能被1和他自身整除
     
function Zhi(i) {
var i=prompt('请输入一个数');
var count=0;
for(var a=1;a&lt;=i;a++) {
   if(i%a==0) {//6 
    count++;
   }
}
   if(count==2) {
    console.log(i+&quot;是质数&quot;);
   }
   else{
    return;
    console.log(i+&quot;不是质数&quot;);
	}
}       
        //求6以内的质数的
function AllZhi(k) {
   for(var j=1;j&lt;=k;j++) {
      Zhi(j);
	}   
}
</code></pre>
<h2 id="六-webapi编程-2020520-2020630">六 . WebAPI编程 2020.5.20-2020.6.30</h2>
<h3 id="1定义">1.定义</h3>
<h4 id="1-api">1. API</h4>
<p>定义 ：API ( Application Programming Interface,应用程序编程接口)是一些预先定义的函数,目的是提供应用程序<br>
与开发人员基于某软件或硬件得以访问一组例程的能力,而双无需访问源码,或理解内部工作机制的细节。</p>
<h4 id="2-web-api">2. web API</h4>
<p>Web API是浏览器提供的一套操作浏览器功能和页面元素的API( BOM和DOM)。</p>
<h4 id="3-区别">3. 区别</h4>
<figure data-type="image" tabindex="96"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588679979760.png" alt="1588679979760" loading="lazy"></figure>
<h3 id="2-dom">2. DOM</h3>
<h4 id="21-dom定义">2.1 DOM定义</h4>
<p>文档对象模型( Document ObjectModel ,简称DOM) , 是W3C组织推荐的处理可扩展标记语言( HTML<br>
或者XML )的标准编程接口。</p>
<h4 id="22-dom-树">2.2 DOM 树</h4>
<figure data-type="image" tabindex="97"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588680131524.png" alt="1588680131524" loading="lazy"></figure>
<figure data-type="image" tabindex="98"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588680168485.png" alt="1588680168485" loading="lazy"></figure>
<h4 id="23-获取元素">2.3 获取元素</h4>
<p>DOM在我们实际开发中主要用来操作元素。<br>
<mark>获取页面中的元素可以使用以下几种方式:</mark><br>
●根据ID获取<br>
●根据标签名获取<br>
●通过HTML5新增的方法获取<br>
●特殊元素获取</p>
<h5 id="1-根据id获取-getelementbyld">1. 根据id获取  getElementByld（）</h5>
<p>使用getElementByld（）方法可以获取带有ID的元素对象。</p>
<ul>
<li>因为我们文档页面从上往下加载，所以先得有标签所以我们script写到标签的下面</li>
<li>get获得element 元素by通过驼峰命名法</li>
<li>参数id是大小写敏感的字符串</li>
<li>返回的是一个元素对象</li>
</ul>
<pre><code class="language-javascript">console.dir()  打印返回的元素对象更好的查看里面的属性和方法
</code></pre>
<h5 id="2根据标签名获取-getelementsbytagname">2.根据标签名获取  getElementsByTagName()</h5>
<p>使用getElementsByTagName()方法可以返回带有指定标签名的对象的集合。</p>
<p>返回的是获取过来的元素对象的集合，以伪数组的形式存储</p>
<figure data-type="image" tabindex="99"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588765974462.png" alt="1588765974462" loading="lazy"></figure>
<p><mark>element.getElementsByTagName() 可以得到元素里面的某些标签</mark></p>
<h5 id="3-通过html5新增的方法获取">3. 通过HTML5新增的方法获取</h5>
<figure data-type="image" tabindex="100"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588815779022.png" alt="1588815779022" loading="lazy"></figure>
<h5 id="4特殊元素获取-bodyhtml">4.特殊元素获取  (body,html)</h5>
<figure data-type="image" tabindex="101"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588816015638.png" alt="1588816015638" loading="lazy"></figure>
<h4 id="24-事件基础">2.4  事件基础</h4>
<h5 id="1-事件概述">1.  事件概述</h5>
<p>JavaScript使我们有能力创建动态页面,而事件是可以被JavaScript侦测到的行为。<br>
简单理解:<mark>触发---响应机制</mark>。<br>
网页中的每个元素都可以产生谋些可以触发JavaScript的事件,例如,我们可以在用户点击某按钮时产生一个<br>
事件,然后去执行某些操作。</p>
<p>事件组成：</p>
<ul>
<li>事件源    事件被触发的对象 （谁）</li>
<li>事件类型    如何触发 什么事件</li>
<li>事件处理程序   通过一个函数赋值的方式完成</li>
</ul>
<h5 id="2执行事件的步骤">2.执行事件的步骤</h5>
<ol>
<li>获取事件源</li>
<li>绑定事件</li>
<li>添加事件处理程序（采取函数赋值形式）</li>
</ol>
<h5 id="3-常见的鼠标事件">3. 常见的鼠标事件</h5>
<figure data-type="image" tabindex="102"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588816681929.png" alt="1588816681929" loading="lazy"></figure>
<h4 id="25-操作元素">2.5 操作元素</h4>
<p>JavaScript的DOM操作可以改变网页内容、结构和样式,我们可以利用DOM操作元素来改变元素里面的内<br>
容、属性等。注意以下都是属性</p>
<h5 id="1-改变元素内容">1. 改变元素内容</h5>
<figure data-type="image" tabindex="103"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588816833564.png" alt="1588816833564" loading="lazy"></figure>
<p>区别：</p>
<ul>
<li>innerText  不识别HTML标签，去除空格和换行</li>
<li><mark>innerHTML  识别HTML标签（推荐）</mark>，保留空格和换行</li>
<li>可读写，可以获取元素的里面的内容</li>
</ul>
<h5 id="2-常用属性操作">2. 常用属性操作</h5>
<figure data-type="image" tabindex="104"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588820811754.png" alt="1588820811754" loading="lazy"></figure>
<h5 id="3-表单元素的属性操作">3.  表单元素的属性操作</h5>
<figure data-type="image" tabindex="105"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588838784420.png" alt="1588838784420" loading="lazy"></figure>
<h5 id="4-样式属性操作">4. 样式属性操作</h5>
<p>可以通过JS 修改元素的大小、颜色、位置等样式</p>
<pre><code class="language-javascript">element.style  行内样式操作
element.className  类名样式操作
</code></pre>
<p>js 里面的样式采取驼峰命名法比如 fontSize、backgroundColor</p>
<p>js 修改style样式操作，产生的是行内样式，css权重比较高</p>
<h5 id="5排他思想">5.排他思想</h5>
<h5 id="6-自定义属性操作">6. 自定义属性操作</h5>
<h6 id="1-获取属性值">1. 获取属性值</h6>
<pre><code>element.属性 （获取属性值）
element.getAttribute('属性')；
</code></pre>
<figure data-type="image" tabindex="106"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1590541400291.png" alt="1590541400291" loading="lazy"></figure>
<h6 id="2-设置属性值">2. 设置属性值</h6>
<pre><code class="language-javascript">element.属性='值'  设置内置属性值
element.setAttribute('属性'，'值')； 针对自定义属性

</code></pre>
<h5 id="7-h5自定义属性">7. H5自定义属性</h5>
<h6 id="1-设置自定义属性">1. 设置自定义属性</h6>
<p>H5规定自定义属性data-开头作为属性名并且赋值</p>
<pre><code class="language-html">&lt;div data-index='1'&gt;&lt;div&gt;
</code></pre>
<p>或者使用js设置</p>
<pre><code class="language-javascript">element.setAttribute('data-index',2)
</code></pre>
<h6 id="2-获取h5自定义属性">2. 获取H5自定义属性</h6>
<figure data-type="image" tabindex="107"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1590628475085.png" alt="1590628475085" loading="lazy"></figure>
<p><mark>dataset 是一个集合里面存放了所有以data开头的自定义属性。如果自定义属性里面有多个-链接的单词，获取的时候采取驼峰命名法</mark></p>
<h4 id="26-节点操作">2.6 节点操作</h4>
<figure data-type="image" tabindex="108"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1590628886835.png" alt="1590628886835" loading="lazy"></figure>
<h5 id="1-节点概述">1. 节点概述</h5>
<figure data-type="image" tabindex="109"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1590628989833.png" alt="1590628989833" loading="lazy"></figure>
<p>一般地， 节点至少拥有nodeType (节类型)、nodeName (节点名称)和nodeValue (节点值)这三个<br>
基本属性。<br>
●元素节点nodeType为1<br>
●属性节点nodeType为2<br>
●文本节点nodeType为3 (文本节点包含文字、空格、换行等)</p>
<h5 id="2-节点层级-父子兄层级关系">2. 节点层级 （父子兄层级关系）</h5>
<h6 id="21-父级节点">2.1 父级节点</h6>
<pre><code class="language-javascript">node.parentNode
//得到的是离元素最近的父级节点（亲爸爸），找不到返回为null
</code></pre>
<h6 id="22-子级节点">2.2 子级节点</h6>
<pre><code class="language-javascript">parentNode.childNodes (标准)   //所有的子节点，包括元素节点、文本节点（包括换行）
parentNode.children (非标准)   //只读属性，返回所有的子元素节点。 
parentNode.firstChild  （标准）  //返回第一个子节点
parentNode.lastChild (标准)     //返回最后一个子节点

parentNode.firstElementChild //返回子元素节点 需IE9以上
parentNode.lastElementChild //返回子元素节点  需IE9以上
</code></pre>
<p>开发中写法：</p>
<pre><code class="language-javascript">console.log(ol.children[0]); //第一个元素节点
console.log(ol.children[ol.children.length - 1]);  //最后元素节点
</code></pre>
<h6 id="23-兄弟节点">2.3 兄弟节点</h6>
<pre><code class="language-javascript">node.nextSibling //返回当前元素的下一个兄弟节点（包含文本节点）
node.previousSibling //返回当前元素的上一个兄弟节点 （包含文本节点）

node.nextElementSibling //下一个兄弟元素节点  需IE9 以上
node.previousElementSibling //上一个兄弟元素节点 需IE9 以上
</code></pre>
<p>兼容性问题解决办法：封装一个兼容性函数,了解</p>
<pre><code class="language-javascript">function getNextElementSibling(element) {
    var el=element;
    while (el= el.nextSibling) {
        if (el.nodeType==1){
            return el；
           
        }
    }
    return null；
}
</code></pre>
<h5 id="3-创建节点">3. 创建节点</h5>
<pre><code>document.createElement('tagName')；
</code></pre>
<h5 id="4-添加节点">4. 添加节点</h5>
<pre><code class="language-javascript">node.appendChild(child)；
</code></pre>
<p>node. appendChild()方法将一个节 点添加到指定父节点的子节点列表末尾。类似于css里的after伪元素。</p>
<pre><code class="language-javascript">node.insertBefore(child,指定元素)
</code></pre>
<p>node . insertBefore ()方法将一个节点添加到父节点的指定子节点前面。类似于css里面的before伪元素。</p>
<h5 id="5-删除节点">5. 删除节点</h5>
<pre><code class="language-javascript">node.removeChild(child)  //从DOM中删除一个子节点，返回删除的节点
</code></pre>
<h5 id="6-复制节点">6. 复制节点</h5>
<pre><code class="language-javascript">node.cloneNode()  //调用该方法的节点的一个副本
//括号为空|false  浅拷贝 只复制标签不复制内容
node.cloneNode(true)  //深拷贝，复制标签，复制内容  
</code></pre>
<h5 id="7-三种动态创建元素的区别">7. 三种动态创建元素的区别</h5>
<figure data-type="image" tabindex="110"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1590654279430.png" alt="1590654279430" loading="lazy"></figure>
<h4 id="27-案例">2.7  案例</h4>
<h5 id="1-精灵图操作">1.  精灵图操作</h5>
<pre><code>获取元素 所有的小li
var lis=document.querySelectorAll('li');
for (var i=0;i&lt;lis.length;i++) {
    //让索引号 乘以44就是每个li的背景y坐标 index就是我们的y坐标
    var index=i * 44;
    lis[i].style.backgroundPosition = '0 -' +index +'px';
}
</code></pre>
<h5 id="2-显示隐藏文本框内容">2. 显示隐藏文本框内容</h5>
<p>①首先表单需要2个新事件,获得点onfocus失法焦点onblur<br>
②如果获得焦点，判断表单里面内容是否为默认文字,如果是默认文字,就清空表单内容<br>
③如果失去焦点,判断表单内容是否为空,如果为空,则表单内容改为默认文字</p>
<figure data-type="image" tabindex="111"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/code1.png" alt="code1" loading="lazy"></figure>
<h5 id="2-tab栏切换">2. tab栏切换</h5>
<h3 id="3-事件高级">3. 事件高级</h3>
<h4 id="31-注册事件-绑定事件">3.1 注册事件  （绑定事件）</h4>
<h5 id="1注册事件概述">1.注册事件概述</h5>
<p>给元素添加事件，称为注册事件或者绑定事件</p>
<p>注册事件有两种方式：传统方式和方法监听注册方式</p>
<figure data-type="image" tabindex="112"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1590971587454.png" alt="1590971587454" loading="lazy"></figure>
<h5 id="2-addeventlistener-事件监听方式">2. addEventListener  事件监听方式</h5>
<pre><code class="language-javascript">eventTarget.addEventListener(type,listener,userCapture)
</code></pre>
<figure data-type="image" tabindex="113"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1590971732978.png" alt="1590971732978" loading="lazy"></figure>
<h5 id="3-注册事件兼容性解决方案">3. 注册事件兼容性解决方案</h5>
<figure data-type="image" tabindex="114"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1590972394882.png" alt="1590972394882" loading="lazy"></figure>
<h4 id="32-删除事件-解绑">3.2 删除事件 （解绑）</h4>
<h5 id="1-传统删除事件">1. 传统删除事件</h5>
<pre><code>eventTarget.removeEventListener(type,listener[，useCapture])；
</code></pre>
<h5 id="2-方法监听注册方式-删除事件">2. 方法监听注册方式 删除事件</h5>
<pre><code>eventTarget.removeEventListener(type,listener[,userCapture])；
eventTarget.detachEvent(eventNameWithon,callback)；
</code></pre>
<h5 id="3-删除事件兼容方案">3. 删除事件兼容方案</h5>
<figure data-type="image" tabindex="115"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1590975118395.png" alt="1590975118395" loading="lazy"></figure>
<h4 id="33-dom-事件流">3.3 DOM 事件流</h4>
<p>事件流描述的是从页面中接收事件的顺序。<br>
事件发生时会在元素节点之间按照特定的顺序传播,这个传播过程即DOM事件流。</p>
<figure data-type="image" tabindex="116"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1590975396056.png" alt="1590975396056" loading="lazy"></figure>
<p>事件发生时会在元素节点之间按照特定的顺序传播,这个传播过程即DOM事件流。<br>
注意:</p>
<ol>
<li>JS代码中只能执行捕获或者冒泡其中的一一个阶段。</li>
<li>onclick和attachEvent只能得到冒泡阶段。</li>
<li>addEventListener (type, listener[, useCapture] )第三个参数如果是true ,表示在事件捕获阶段调用事件处理程序;如果是false (不写默认就是false ) , 表示在事件冒泡阶段调用事件处理程序。</li>
<li>实际开发中我们很少使用事件捕获,我们更关注<mark>事件冒泡</mark>。</li>
<li>有些事件是没有冒泡的,比如onblur、onfocus、 onmouseenter、 onmouseleave</li>
</ol>
<h4 id="34-事件对象">3.4 事件对象</h4>
<ol>
<li>event 就是一个事件对象写到我们侦听函数的小括号里面当形参来看</li>
<li>事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数</li>
<li>事件对象是我们事件的一系列相关数据的集合跟事件相关的比如鼠标点击里面就包含了鼠标的相关信息鼠标坐标啊，如果是键盘事件里面就包含的键盘事件的信息比如判断用户按下了那个键</li>
<li>这个事件对象我们可以自己命名比如event、evt、e</li>
<li>事件对象也有兼容性问题 ie 678通过window. event</li>
</ol>
<h5 id="1-常见事件对象属性和方法">1. 常见事件对象属性和方法</h5>
<table>
<thead>
<tr>
<th>事件对象属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>e.target</td>
<td>返回触发事件的对象                       标准</td>
</tr>
<tr>
<td>e.srcElement</td>
<td>返回触发事件的对象              非标准 IE6-8</td>
</tr>
<tr>
<td>e.type</td>
<td>返回事件的类型  比如click mouseover  不带on</td>
</tr>
<tr>
<td>e.cancelBubble</td>
<td>该属性阻止冒泡  非标准 IE6-8</td>
</tr>
<tr>
<td>e.returnValue</td>
<td>该属性阻止默认事件（默认行为） 非标准  IE6-8  比如不让链接跳转</td>
</tr>
<tr>
<td>e.preventDefault()</td>
<td>该方法阻止默认事件   标准</td>
</tr>
<tr>
<td>e.stopPropagation()</td>
<td>阻止冒泡  标准</td>
</tr>
</tbody>
</table>
<p><mark>e.target  返回触发事件的对象；this | currentTarget(需兼容)返回绑定事件的对象（元素）</mark></p>
<h4 id="35-阻止事件冒泡">3.5 阻止事件冒泡</h4>
<h5 id="1-阻止冒泡的两种方式">1. 阻止冒泡的两种方式</h5>
<figure data-type="image" tabindex="117"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591001541548.png" alt="1591001541548" loading="lazy"></figure>
<h5 id="2-阻止事件冒泡兼容解决方案">2. 阻止事件冒泡兼容解决方案</h5>
<figure data-type="image" tabindex="118"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591001507816.png" alt="1591001507816" loading="lazy"></figure>
<h4 id="36-事件委托">3.6 事件委托</h4>
<p><mark>核心原理：给父节点添加监听器，利用事件冒泡影响每一个子节点</mark></p>
<h4 id="37-鼠标事件">3.7 鼠标事件</h4>
<figure data-type="image" tabindex="119"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591002838468.png" alt="1591002838468" loading="lazy"></figure>
<h5 id=""></h5>
<table>
<thead>
<tr>
<th>鼠标事件对象</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>e.clientX</td>
<td>返回鼠标相对于浏览器可视区的X坐标</td>
</tr>
<tr>
<td>e.clentY</td>
<td>返回鼠标相对于浏览器可视区的Y坐标</td>
</tr>
<tr>
<td>e.pageX</td>
<td>返回相当于文档页面的X 坐标  IE9+支持</td>
</tr>
<tr>
<td>e.pageY</td>
<td>返回相当于文档页面的Y坐标  IE9+支持</td>
</tr>
<tr>
<td>e.screenX</td>
<td>返回鼠标相对于电脑屏幕的X坐标</td>
</tr>
<tr>
<td>e.screenY</td>
<td>返回鼠标相对于电脑屏幕的Y坐标</td>
</tr>
</tbody>
</table>
<h4 id="38-鼠标事件">3.8 鼠标事件</h4>
<h5 id="1-常用鼠标事件">1. 常用鼠标事件</h5>
<table>
<thead>
<tr>
<th>键盘事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>onkeyup</td>
<td>某个键盘按键被松开时触发（不区分大小写）</td>
</tr>
<tr>
<td>onkeydown</td>
<td>某个键盘按键被按下时触发（不区分大小）</td>
</tr>
<tr>
<td>onkeypress</td>
<td>某个键盘按键被按下时触发   不识别功能键（Ctrl、shift） 区分大小写</td>
</tr>
</tbody>
</table>
<ol>
<li>如果使用addEventListener不需要加on</li>
<li>onkeypress 和前面2个的区别是,它不识别功能键,比如左右箭头, shift等。</li>
<li>三个事件的执行顺序是: keydown-- keypress --- keyup</li>
</ol>
<h5 id="2-键盘事件对象">2. 键盘事件对象</h5>
<table>
<thead>
<tr>
<th>键盘事件对象属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>keyCode</td>
<td>返回该键的ASCII值</td>
</tr>
</tbody>
</table>
<p>注意: onkeydown 和onkeyup区分字母大小写, onkeypress区分字母大小写。<br>
在我们实际开发中,我们更多的使用keydown和keyup，它能识别所有的键(包括功能键)<br>
Keypress不识别功能键,但是keyCode属性能区分大小写,返回不同的ASCI值</p>
<h3 id="4-bom-浏览器对象模型">4. BOM 浏览器对象模型</h3>
<h4 id="41-bom-概述">4.1 BOM 概述</h4>
<p>BOM ( Browser Object Model )即浏览器对象模型,它提供了独立于内容而与浏览器窗口进行交互的对象,其核心<br>
对象是window。<br>
BOM由一系列相关的对象构成 ,并且每个对象都提供了很多方法与属性。</p>
<figure data-type="image" tabindex="120"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591168811827.png" alt="1591168811827" loading="lazy"></figure>
<figure data-type="image" tabindex="121"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591168932250.png" alt="1591168932250" loading="lazy"></figure>
<p>window对象是浏览器的顶级对象,它具有双重色。<br>
1.它是JS访问浏览器窗口的一一个接口。<br>
2.它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window对象的属性和方法。<br>
在调用的时候可以省略window ,前面学习的对话框都属于window对象方法,如alert(）、prompt（）等。</p>
<h4 id="42-windows-对象的常见事件">4.2 Windows 对象的常见事件</h4>
<h5 id="窗口加载事件">窗口加载事件</h5>
<pre><code class="language-javascript">windouws.onload=function() {
    
};或者
Windows.addEventListener('load',function(){
    
});
</code></pre>
<p>window.onload是窗口(页面)加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS<br>
文件等),就调用的处理函数。</p>
<figure data-type="image" tabindex="122"><img src="C:%5CUsers%5Clenovo%5CDocuments%5CGridea%5Cweb%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%5C1591169676903.png" alt="1591169676903" loading="lazy"></figure>
<pre><code class="language-javascript">document.addEventListener('DOMContentLoaded',function(){})
</code></pre>
<p>DOMContentLoaded事件触发时，仅当DOM加载完成,不包括样式表,图片, flash等。<br>
le9以上才支持<br>
如果页面的图片很多的话,从用户访问到onload触发可能需要较长的时间，交互效果就不能实现,必然影响用<br>
户的体验,此时用DOMContentLoaded事件比较合适。</p>
<p>渲染速度： DOMContentLoaded &gt; load</p>
<p>load等页面内容全部加载完毕，包含页面dom元素图片flash、CSS等等<br>
DOMContentLoaded是DOM加载完毕，不包含图片falsh Css等就可以执行加载速度比load更快些</p>
<h5 id="调整窗口大小事件">调整窗口大小事件</h5>
<pre><code class="language-javascript">Windows.onresize=function(){}
windows.addEventListener('resize',function(){})
</code></pre>
<figure data-type="image" tabindex="123"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591170388402.png" alt="1591170388402" loading="lazy"></figure>
<h4 id="43-定时器-settimeout-setinterval">4.3 定时器 setTimeout /setInterval</h4>
<h5 id="431-settimeout">4.3.1 setTimeout</h5>
<pre><code class="language-javascript">windows.setTimeout(调用函数，[延迟的毫秒数])；
</code></pre>
<p>setTimeout(方法用于设置一个定时器 ,该定时器在定时器到期后执行调用函数。</p>
<p>语法规范:  window . setTimeout(调用函数，延时时间);</p>
<ol>
<li>这个window在调用的时候可以省略</li>
<li>这个延时时间单位是毫秒但是可以省略，如果省略默认的是0</li>
<li>这个调用函数可以直接写函数还可以写函数名还有一个写法'函数名() '</li>
<li>页面中可能有很多的定时器，我们经常给定时器加标识符 (名字)</li>
</ol>
<figure data-type="image" tabindex="124"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591170932708.png" alt="1591170932708" loading="lazy"></figure>
<p>setTimeout()这个调用函数我们也称为回调函数callback<br>
普通函数是按照代码顺序直接调用。而这个函数,需要等待时间,时间到了才去调用这个函数,因此称为回调函数。<br>
简单理解:回调,就是回头调用的意思。上一 件事轩完,再回头再调用这个函数。<br>
以前我们讲的element. onclick = function(){}或者element.addEventListener(&quot;click&quot; , fn);里面的函数也是回调<br>
函数。</p>
<h5 id="432-停止settimeout-定时器">4.3.2 停止setTimeout() 定时器</h5>
<pre><code class="language-javascript">Windows.clearTimeout(timeoutID)
</code></pre>
<figure data-type="image" tabindex="125"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591236649254.png" alt="1591236649254" loading="lazy"></figure>
<h5 id="433-setinterval-定时器">4.3.3  setInterval 定时器</h5>
<pre><code>Windows.setInterval(回调函数，[间隔的毫秒数])；
</code></pre>
<figure data-type="image" tabindex="126"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591236804939.png" alt="1591236804939" loading="lazy"></figure>
<h5 id="434-区别">4.3.4 区别</h5>
<p>setTimeout ：延迟时间到。调用一次函数</p>
<p>setInterval：每隔延迟时间，调用一次，重复调用</p>
<h5 id="435-停止setinterval">4.3.5 停止setInterval</h5>
<pre><code>Windows.clearInterval(intervalID);
</code></pre>
<figure data-type="image" tabindex="127"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591239723689.png" alt="1591239723689" loading="lazy"></figure>
<h5 id="436-this-指向">4.3.6  this 指向</h5>
<p>this的指向在函数定义的时候是确定不了的,只有函数执行的时候才能确定this到底指向谁,一般情况 下this<br>
的最终指向的是那个<mark>调用它的对象</mark></p>
<p>全局作用域：</p>
<h4 id="44-js执行队列">4.4 JS执行队列</h4>
<figure data-type="image" tabindex="128"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591405838531.png" alt="1591405838531" loading="lazy"></figure>
<h5 id="1-同步-异步">1. 同步、异步</h5>
<p>同步 ：前一个任务结束后再执行后一个任务,程序的执行顺序与任务的排列顺序是一致的、 同步的。</p>
<p>异步：你在做一件事情时,因为这件事情会花费很长时间,在做这件事的同时,你还可以法处理其他事情。比如做<br>
饭的异步做法,我们在烧水的同时, 利用这10分钟,切菜,炒菜。</p>
<figure data-type="image" tabindex="129"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591406555095.png" alt="1591406555095" loading="lazy"></figure>
<h4 id="45-location对象">4.5 location对象</h4>
<h5 id="1-概述">1. 概述</h5>
<p>window对象给我们提供了-一个location属性用于获取或设置窗体的URL ,并组可以用于解析URL。因为，这个属性返回的是一个对象 ,所以我们将这个属性也称为location对象。</p>
<h5 id="2-url">2. URL</h5>
<figure data-type="image" tabindex="130"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591490607952.png" alt="1591490607952" loading="lazy"></figure>
<figure data-type="image" tabindex="131"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591490676685.png" alt="1591490676685" loading="lazy"></figure>
<h5 id="3location-常见属性">3.location 常见属性</h5>
<figure data-type="image" tabindex="132"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591490761460.png" alt="1591490761460" loading="lazy"></figure>
<h5 id="4-location-对象的方法">4. location 对象的方法</h5>
<figure data-type="image" tabindex="133"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591492093275.png" alt="1591492093275" loading="lazy"></figure>
<h4 id="46-navigator-对象">4.6  navigator 对象</h4>
<p>navigator对象包含有关浏览器的信息,它有很多属性,我们最常用的是userAgent ,该属性可以返回由客<br>
户机发送服务器的user-agent头部的值。</p>
<figure data-type="image" tabindex="134"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591492468406.png" alt="1591492468406" loading="lazy"></figure>
<h4 id="47-history-对象">4.7 history 对象</h4>
<p>window对象给我们提供了-个history对象,与浏览器历史记录进行交互。该对象包含户(在浏览器窗口中)<br>
访问过的URL。</p>
<figure data-type="image" tabindex="135"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591492700924.png" alt="1591492700924" loading="lazy"></figure>
<h3 id="5-网页特效">5. 网页特效</h3>
<h4 id="51-元素偏移量-offset系列">5.1 元素偏移量 offset系列</h4>
<h5 id="1-概述-2">1. 概述</h5>
<p>offset： 偏移量，可以动态的得到该元素的位置（偏移）、大小</p>
<ul>
<li>获得元素距离带有<mark>定位父元素</mark>的位置，无定位以body为准</li>
<li>获得元素自身的大小（宽度高度，是包含padding、border）</li>
<li>注意：返回的数值都不带单位</li>
</ul>
<figure data-type="image" tabindex="136"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591577122904.png" alt="1591577122904" loading="lazy"></figure>
<p>node.parentNode 返回父亲是最近一级的亲爸爸（不管有没有定位，都是亲爸爸）</p>
<h5 id="2-offset-与-style-区别">2. offset 与 style 区别</h5>
<figure data-type="image" tabindex="137"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1591577676465.png" alt="1591577676465" loading="lazy"></figure>
<h5 id="3-京东放大镜案例-大图片移动距离">3. 京东放大镜案例-大图片移动距离</h5>
<figure data-type="image" tabindex="138"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1592382110075.png" alt="1592382110075" loading="lazy"></figure>
<h4 id="2-元素可视区client系列">2. 元素可视区client系列</h4>
<p>client翻译过来就是客户端,我们使用client系列的相关属性来获取元素可视区的相关信息。通过client系列<br>
的相关属性可以动态的得到该元素的边框大小、元素大等。</p>
<figure data-type="image" tabindex="139"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1592382418742.png" alt="1592382418742" loading="lazy"></figure>
<h5 id="1-立即执行函数-不需要调用">1. 立即执行函数 -不需要调用</h5>
<figure data-type="image" tabindex="140"><img src=".%5Cclient1.png" alt="client1" loading="lazy"></figure>
<p>第二个小括号可以看做调用函数</p>
<p>优点：独立创建了一个作用域（局部作用域），都是局部变量，不用担心变量名重名</p>
<figure data-type="image" tabindex="141"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1592383536773.png" alt="1592383536773" loading="lazy"></figure>
<h4 id="3-元素滚动scroll-系列">3. 元素滚动scroll 系列</h4>
<h5 id="1-scroll-属性">1. scroll 属性</h5>
<p>scroll翻译过来就是滚动的,我们使用scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p>
<figure data-type="image" tabindex="142"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1592443469665.png" alt="1592443469665" loading="lazy"></figure>
<figure data-type="image" tabindex="143"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1592443641204.png" alt="1592443641204" loading="lazy"></figure>
<h5 id="2-页面被卷去的头部">2. 页面被卷去的头部</h5>
<p>如果浏览器的高(或宽)度不足以显示整个页面时,会自动出现滚动条。当滚动条向下滚动时,页面上面被隐藏<br>
掉的高度,我们就称页面被卷去的头部。滚动条在滚动时会触发onscroll事件。</p>
<p>案例：淘宝右侧固定栏</p>
<figure data-type="image" tabindex="144"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1592444201361.png" alt="1592444201361" loading="lazy"></figure>
<h5 id="3-区别比较">3. 区别比较</h5>
<figure data-type="image" tabindex="145"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1592444888170.png" alt="1592444888170" loading="lazy"></figure>
<figure data-type="image" tabindex="146"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1592444978794.png" alt="1592444978794" loading="lazy"></figure>
<h5 id="4-mouseenter-和-mouseover-的区别">4. mouseenter 和 mouseover 的区别</h5>
<figure data-type="image" tabindex="147"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1592483497510.png" alt="1592483497510" loading="lazy"></figure>
<h4 id="4-动画函数封装">4. 动画函数封装</h4>
<h5 id="1-动画实现原理">1. 动画实现原理</h5>
<p>核心原理：通过定时器setInterval() 不断移动盒子位置</p>
<p>动画原理<br>
1.获得盒子当前位置<br>
2.让盒子在当前位置加上1个移动距离<br>
3.利用定时器不断重复这个操作<br>
4.加一个结束定时器的条件<br>
5.注意此元素需要添加定位， 才能使用element . style. left</p>
<h5 id="2-动画函数简单封装">2.  动画函数简单封装</h5>
<p>注意函数需要传递两个参数，动画对象和移动到的距离</p>
<h5 id="3-动画函数-给不同元素记录不同定时器">3. 动画函数 给不同元素记录不同定时器</h5>
<p>如果多个元素都使用这个动画函数, 每次都要var声明定时器。我们可以给不同的元素使用不同的定时器(自<br>
专门用自己的定时器)。<br>
<mark>核心原理:利用JS是一门动态语言,可以很方便的给当前对象添加属性。</mark></p>
<h5 id="4-缓动效果原理">4. 缓动效果原理</h5>
<p>缓动动画就是让元素运动速度有所变化,最常见的是让速度慢慢停下来</p>
<p><mark>核心算法：（目标值-现在的位置）/10 作为每次移动的距离步 长</mark></p>
<img src="file://C:/Users/lenovo/Documents/Gridea/post-images/animate.png" alt="animate" style="zoom: 50%;" />
<h5 id="5-动画函数添加回调函数">5. 动画函数添加回调函数</h5>
<p>回调函数原理:函数可以作为一个参数。 将这个函数作为参数传到另一个函数里面,当那个函数执行完之后<br>
,再执行传进去的这个函数,这个过程就叫做回调。</p>
<p>回调函数写在定时器结束里面</p>
<h4 id="5-节流阀">5. 节流阀</h4>
<p>防止轮播图按钮连续点击造成播放过快</p>
<p>节流阀目的:当上一一个函数动画内容执行完毕,再去执行下一个函数动画,让事件无法连续触发。</p>
<figure data-type="image" tabindex="148"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200623091056009.png" alt="image-20200623091056009" loading="lazy"></figure>
<p>案例：品优购轮播图</p>
<h3 id="6-移动端网页特效">6. 移动端网页特效</h3>
<h4 id="1-触屏事件">1. 触屏事件</h4>
<h5 id="11-触屏事件基础">1.1 触屏事件基础</h5>
<p>移动端浏览器兼容性较好,我们不要考虑以前JS的兼容性问题,可以放心的使用原生JIS 泻效果,但是移动<br>
端也有自己独特的地方。比如触屏事件touch (也称触摸事件) , Android和I0S都有。</p>
<p>touch对象代表一个触摸点。 触摸点可能是一根手指,也可能是一根触摸笔。触屏事件可响应用户手指(或触控<br>
笔)对屏幕或者触控板操作。</p>
<figure data-type="image" tabindex="149"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200623094622135.png" alt="image-20200623094622135" loading="lazy"></figure>
<h5 id="12触摸事件对象">1.2.触摸事件对象</h5>
<p>TouchEvent是一类描述手指在触摸平面(触摸屏、触摸板等)的状态变化的事件。这类事件用于描述一个或多<br>
个触点,使研发者可以检测触点的移动,触点的增加和减少,等等<br>
touchstart、touchmove、touchend 三个事件都会各自有事件对象。<br>
触摸事件对象重点我们看三个常见对象列表:</p>
<figure data-type="image" tabindex="150"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200626092947245.png" alt="image-20200626092947245" loading="lazy"></figure>
<h5 id="13-移动端拖动元素">1.3 移动端拖动元素</h5>
<ol>
<li>touchstart、touchmove、 touchend 可以实现拖动元素</li>
<li>但是拖动元素需要当前手指的坐标值我们可以使用targetTouches[0] 里面的pageX和pageY</li>
<li>移动端拖动原理：手指移动中，计算出手指移动的距离。盒子原来的距离+手指移动的距离</li>
<li>手指移动的距离：手指滑动中的位置-手指触摸的位置</li>
</ol>
<figure data-type="image" tabindex="151"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200626094535511.png" alt="image-20200626094535511" loading="lazy"></figure>
<p>案例：携程移动端-轮播图</p>
<h5 id="14-classlist-属性">1.4  classList 属性</h5>
<p>h5新增属性，返回元素的类名（ie 10 以上）</p>
<pre><code class="language-javascript">element.classList.add('类名');添加类: 在后面追加类名，不需要加.
element.classList.remove('类名'); 删除
element.classList.toggle('类名');  切换类
</code></pre>
<h4 id="2-移动端常见特效">2. 移动端常见特效</h4>
<h5 id="案例携程手机端-返回顶部">案例：携程手机端-返回顶部</h5>
<h5 id="22-click-延时解决方案">2.2  click 延时解决方案</h5>
<p>移动端click事件会有300ms的延时,原因是移动端屏幕双击会缩放(double tap to zoom)面。</p>
<p>解决方案：</p>
<ol>
<li>
<p>禁止缩放。浏览器禁用默认的双击缩放行为并且去掉300ms 的点击延迟</p>
<pre><code>&lt;meta name='viewport' content='user-scalable=no'&gt;//user-scalable=no禁止缩放
</code></pre>
</li>
<li>
<p>利用touch事件封装</p>
<figure data-type="image" tabindex="152"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200628082417630.png" alt="image-20200628082417630" loading="lazy"></figure>
</li>
</ol>
<figure data-type="image" tabindex="153"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200628082608189.png" alt="image-20200628082608189" loading="lazy"></figure>
<h4 id="3-移动端常见开发插件">3. 移动端常见开发插件</h4>
<p>移动端要求的是快速开发,所以我们经常会借助于些插件来帮我完成操作 ,那么什么是插件呢?<br>
JS插件是js文件,它遵循一定规范编写,方便程序展示效果, 拥有特定功能且方便调用。如轮播图和瀑布流插件。<br>
特点:它一般是为了解决某个问题而专门存在,期能单一 , 并且比较小。</p>
<h5 id="fastclick-插件解决300ms延迟-使用延时">fastclick 插件解决300ms延迟。使用延时</h5>
<h5 id="移动端视频插件zymediajs">移动端视频插件：zy.media.js</h5>
<h5 id="swiper-轮播图插件">Swiper 轮播图插件</h5>
<p>插件使用：</p>
<figure data-type="image" tabindex="154"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200628153236689.png" alt="image-20200628153236689" loading="lazy"></figure>
<h3 id="7-本地存储">7. 本地存储</h3>
<h4 id="本地存储特性">本地存储特性</h4>
<figure data-type="image" tabindex="155"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200629080856261.png" alt="image-20200629080856261" loading="lazy"></figure>
<h4 id="windowsessionstorage">window.sessionStorage</h4>
<ol>
<li>生命周期为关闭浏览器窗口（当前页面）</li>
<li>在同一窗口（页面）数据可以共享</li>
<li>以键值对的形式存储使用</li>
</ol>
<pre><code class="language-javascript">sessionStorage.setItem(key,valus)//存储数据
sessionStorage.getItem(key) //获取数据
sessionStorage.removeItem(key) //删除数据
sessionStorage.clear() //删除所有数据
</code></pre>
<h4 id="windowlocalstorage">window.localStorage</h4>
<ol>
<li>生命周期永久生效，除非手动删除否则关闭页面还存在</li>
<li>可以多窗口（页面）共享（同一浏览器可以共享）</li>
<li>以键值对的形式存储</li>
</ol>
<pre><code class="language-javascript">localStorage.setItem(key,value)  //存储数据
localStorage.getItem(key)    //获取数据
localStorage.removeItem(key)  //删除数据
localStorage.clear()  //删除所有的数据
</code></pre>
<h4 id="本地存储之cookie">本地存储之cookie</h4>
<h5 id="cookie定义">cookie定义</h5>
<p>Cookie是存储在浏览器端的一些字符串信息,是一种会话跟踪技术,把用户在浏览器的一些信息存储在本地,便于下次自动读取.</p>
<h5 id="cookie-的局限性">cookie 的局限性</h5>
<p>1.IE6 或更低版本最多 20 个 cookie<br>
2.IE7 和之后的版本最多可以 50 个 cookie。 IE7 最初也只能 20 个， 之后因被升级不定后增加了。<br>
3.Firefox 最多 50 个 cookie<br>
4.Opera 最多 30 个 cookie<br>
5.Safari 和 Chrome 没有做硬性限制。<br>
第二：cookie 的最大大约为 4096 字节(<mark>4k</mark>)，为了更好的兼容性，一般不能超过 4095 字节即可。<br>
第三：cookie 存储在客户端的文本文件，所以特别重要和敏感的数据是不建议保存在cookie 的。比如银行卡号，用户密码等<br>
第四:cookie可能被禁用<br>
优点: 兼容性好</p>
<p><mark>cookie 路径:</mark></p>
<pre><code class="language-javascript">document.cookie=&quot;username=John Doe;path=/&quot;  // cookie路径
</code></pre>
<p><mark>设置cookie</mark></p>
<pre><code class="language-javascript">function setCookie(cname,cdate){
	var d=new Date();			
	console.log(d.getDay());
	d.setDate(d.getDate()+cdate)
	var expires=&quot;;expires=&quot;+d
	document.cookie=&quot;name=&quot;+cname+expires;
	console.log(document.cookie);
}
setCookie('mm',1)
</code></pre>
<h5 id="cookie封装getcookie"><mark>cookie封装getcookie</mark></h5>
<p>增加cookie:  注意key相同会产生覆盖<br>
删除cookie:  调用增加cookie方法即可,让时间过期来实现删除.<br>
读取cookie:  注意document.cookie在获取时会返回所有的cookie所对应的字符串<br>
修改cookie : 更改cookie中某条数据所对应的值,先查找后写入新的cookie</p>
<p>方案: 1,字符串分割 2,正则表达式</p>
<pre><code class="language-javascript">//方法一,字符串分割,以username=为突破口
function getName(cname) {
	var name=cname+'=';
	var namearr=document.cookie.split(&quot;;&quot;)
	console.log(namearr);
	for(var a=0;a&lt;namearr.length;a++) {
		var namestr=namearr[a].trim();//trim去除字符串的头尾空格
		console.log(namestr);
		if(namestr.indexOf(name)==0) {
			return namestr.substring(name.length)//substring() 方法用于提取字符串中介于两个指定下标之间的字符。substring() 方法返回的子串包括 开始 处的字符，但不包括 结束 处的字符。
		}
	}
}
getName('name')
</code></pre>
<h2 id="七-jquery-进阶-2020630-202076">七. jQuery   进阶  2020.6.30-2020.7.6</h2>
<h3 id="jquery概述">jQuery概述</h3>
<h4 id="1javascript库">1.JavaScript库</h4>
<p>JavaScript库:即library , 是一个封装好的特定的集合(方法和函数)。从封装一大堆函数的角度理解库,就<br>
是在这个库中,封装了很多预先定义好的函数在里面,比如动画animate、hide、 show ,比如获取元素等。</p>
<p>简单理解:就是一个JS 文件,里面对我们原生js代码进行了封装,存放到里面。这样我们可以快速高效的使用<br>
这些封装好的功能了。</p>
<figure data-type="image" tabindex="156"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200630081647390.png" alt="image-20200630081647390" loading="lazy"></figure>
<figure data-type="image" tabindex="157"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200630082025445.png" alt="image-20200630082025445" loading="lazy"></figure>
<h4 id="2-jquery-入口函数">2. jQuery 入口函数</h4>
<pre><code class="language-javascript">$(function(){
   ..//此处是页面DOM加载完成的入口
});

$(document).ready(function(){
   ...//此处是页面DOM加载完成的入口
});
</code></pre>
<figure data-type="image" tabindex="158"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200630083708024.png" alt="image-20200630083708024" loading="lazy"></figure>
<h4 id="3-jquery-的顶级对象">3. jQuery 的顶级对象$</h4>
<figure data-type="image" tabindex="159"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200630084212462.png" alt="image-20200630084212462" loading="lazy"></figure>
<h4 id="4-jquery对象和dom对象">4. jQuery对象和DOM对象</h4>
<p>DOM对象：通过原生js获取过来的对象</p>
<p>jQuery对象：用jQuery方式获取过来的对象。</p>
<p>本质是通过$把DOM元素进行了包装，产生的对象用伪数组形式存储</p>
<p>jQuery对象只能使用jQuery方法，DOM对象使用原生的JavaScript属性和方法</p>
<p>DOM对象与jQuery对象之间是可以相互转换的。<br>
因为原生js比jQuery大,原生的一些属性和方法 jQuery没有给我们封装要想使用这些属性和方法需要把<br>
jQuery对象转换为DOM对象才能使用。</p>
<pre><code class="language-javascript">&lt;video&gt;&lt;/video&gt;
$('video');//直接获取为jQuery对象
var myvideo=document.querySelector('video');
$(myvideo);//从原生DOM转化为jQuery对象

$('video')[index]  //jQuery对象转化为DOM对象
</code></pre>
<figure data-type="image" tabindex="160"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200630155831830.png" alt="image-20200630155831830" loading="lazy"></figure>
<h3 id="jquery-常用api">jQuery 常用API</h3>
<h4 id="1-jquery-选择器">1. jQuery 选择器</h4>
<pre><code class="language-javascript">$('选择器')//里面选择器直接写css选择器即可。但是要加引号
</code></pre>
<figure data-type="image" tabindex="161"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200630160153767.png" alt="image-20200630160153767" loading="lazy"></figure>
<figure data-type="image" tabindex="162"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200630160747419.png" alt="image-20200630160747419" loading="lazy"></figure>
<figure data-type="image" tabindex="163"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200630161122677.png" alt="image-20200630161122677" loading="lazy"></figure>
<h5 id="1-隐式迭代">1.  隐式迭代</h5>
<p>遍历内部DOM元素(伪数组形式存储)的过程就叫做隐式迭代。<br>
简单理解:给匹配到的所有元素进行循环遍历,执行相应的方法,而不用我们再进行循环,简化我们的操作,<br>
方便我们调用。</p>
<h5 id="2-jquery筛选选择器">2. jQuery筛选选择器</h5>
<figure data-type="image" tabindex="164"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200701075513576.png" alt="image-20200701075513576" loading="lazy"></figure>
<h5 id="3-jquery筛选方法">3. jQuery筛选方法</h5>
<figure data-type="image" tabindex="165"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200701075800053.png" alt="image-20200701075800053" loading="lazy"></figure>
<h4 id="2-jquery样式操作">2. jQuery样式操作</h4>
<h5 id="css方法">CSS方法</h5>
<figure data-type="image" tabindex="166"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200701153701958.png" alt="image-20200701153701958" loading="lazy"></figure>
<p>其中3，如果是复合属性则必须采取驼峰命名法，如果值不是数字，则需要加引号</p>
<h5 id="设置类样式方法"><mark>设置类样式方法</mark></h5>
<p>作用等同于以前的classList ,可以操作类样式,注意操作类里面的参数不要加点。</p>
<figure data-type="image" tabindex="167"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200701154557537.png" alt="image-20200701154557537" loading="lazy"></figure>
<h5 id="类操作与classname区别">类操作与className区别</h5>
<p>原生JS中className会覆元素原先里面的名。<br>
jQuery里面类操作只是对指定类进行操作,不影响原先的类名。</p>
<h4 id="3-jquery-动画效果">3.  jQuery 动画效果</h4>
<figure data-type="image" tabindex="168"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200701183950514.png" alt="image-20200701183950514" loading="lazy"></figure>
<h5 id="显示隐藏效果">显示隐藏效果</h5>
<pre><code class="language-javascript">show([speed],[easing],[fn])
//参数都可以省略。无动画直接显示
//speed：三种预定速度之一的字符串（'slow'，&quot;normal&quot;,&quot;fast&quot;）或表示动画时长的毫秒数值
//easing:(optional)用来指定切换效果，默认是&quot;swing&quot;,可用参数”linear“
//fn:回调函数，在动画完成时执行的函数，每个元素执行一次

//一般情况下不加参数，动画丑
</code></pre>
<h5 id="滑动效果">滑动效果</h5>
<ul>
<li>slideDown()</li>
<li>slideUp()</li>
<li>slideToggle()</li>
</ul>
<h5 id="事件切换">事件切换</h5>
<pre><code>hover([over],[out])
</code></pre>
<h5 id="动画队列及停止排队方法">动画队列及停止排队方法</h5>
<p>动画或者效果一旦触发就会执行,如果多次触发, 就造成多个动画或者效果排队执行。</p>
<figure data-type="image" tabindex="169"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200701190340749.png" alt="image-20200701190340749" loading="lazy"></figure>
<h5 id="淡入淡出效果">淡入淡出效果</h5>
<figure data-type="image" tabindex="170"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200701191911525.png" alt="image-20200701191911525" loading="lazy"></figure>
<h5 id="自定义动画">自定义动画</h5>
<figure data-type="image" tabindex="171"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200701192355973.png" alt="image-20200701192355973" loading="lazy"></figure>
<h4 id="4-jquery-属性操作">4. jQuery 属性操作</h4>
<h5 id="设置或获取元素的固有属性值prop">设置或获取元素的固有属性值prop()</h5>
<p>所谓元素固有属性就是元素本身自带的属性,比如<a>元素里面的href, 比如<input>元素里面的type.</p>
<figure data-type="image" tabindex="172"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200702150433586.png" alt="image-20200702150433586" loading="lazy"></figure>
<h5 id="设置或获取元素自定义属性值attr">设置或获取元素自定义属性值attr()</h5>
<p>用户自定义元素添加的属性，栗给div添加index=&quot;1&quot;</p>
<figure data-type="image" tabindex="173"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200702151037231.png" alt="image-20200702151037231" loading="lazy"></figure>
<h5 id="数据缓存data">数据缓存data()</h5>
<p>data()方法可以在指定的元素上存取数据,并不会修改DOM元素结构。一旦面刷新,之前存放的数据都将被移除。</p>
<figure data-type="image" tabindex="174"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200702151339064.png" alt="image-20200702151339064" loading="lazy"></figure>
<h5 id="案例品优购购物车全选按钮">案例：品优购购物车全选按钮</h5>
<p>全选思路:面3个小的复选框按钮( j-checkbox )选中状态( checked )跟着全选按钮( checkall )走。</p>
<p><mark>:checked选择器:checked 查找被选中的表单元素。</mark></p>
<h4 id="5-jquery-内容文本值">5. jQuery 内容文本值</h4>
<p>主要针对元素的内容、表单的值操作</p>
<h5 id="1-普通元素内容html-相当于原生inner-html">1. 普通元素内容html()  (相当于原生inner Html)</h5>
<pre><code class="language-javascript">html()  //获取元素的内容
html(&quot;内容&quot;)  //设置元素的内容
</code></pre>
<h5 id="2-普通元素文本内容-text-相当于原生innertext">2. 普通元素文本内容 text()  (相当于原生innerText)</h5>
<figure data-type="image" tabindex="175"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200702154143374.png" alt="image-20200702154143374" loading="lazy"></figure>
<h5 id="3-表单的值val-相当于原生value">3. 表单的值val()  (相当于原生value)</h5>
<h5 id="案例品优购-购物车">案例：品优购-购物车</h5>
<p><mark>parents(&quot;选择器&quot;)：可以返回指定祖先元素</mark></p>
<p>toFixed()  :把 Number 四舍五入为指定小数位数的数字。</p>
<h4 id="6-jquery-元素操作">6. jQuery  元素操作</h4>
<p>主要是遍历、创建、添加、删除元素操作。</p>
<h5 id="1-遍历元素">1. 遍历元素</h5>
<p>jQuery隐式迭代是对同一元素做了同样的操作。如果想要给同一 元素做不同操作,就需要用到遍历。</p>
<figure data-type="image" tabindex="176"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200703100336249.png" alt="image-20200703100336249" loading="lazy"></figure>
<figure data-type="image" tabindex="177"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200703101403261.png" alt="image-20200703101403261" loading="lazy"></figure>
<h5 id="2-创建元素">2. 创建元素</h5>
<figure data-type="image" tabindex="178"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200703102740316.png" alt="image-20200703102740316" loading="lazy"></figure>
<h5 id="3-添加元素">3. 添加元素</h5>
<h6 id="内部添加">内部添加</h6>
<figure data-type="image" tabindex="179"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200703102842144.png" alt="image-20200703102842144" loading="lazy"></figure>
<p>prepend  是放在前面</p>
<h6 id="外部添加">外部添加</h6>
<figure data-type="image" tabindex="180"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200703103034697.png" alt="image-20200703103034697" loading="lazy"></figure>
<h5 id="4-删除元素">4. 删除元素</h5>
<pre><code class="language-javascript">element.remove()//删除匹配的元素本身

element.empty()  //删除匹配的元素集中所有的子节点

element.html(&quot;&quot;) //清空匹配的元素内容
</code></pre>
<h3 id="jquery-事件">jQuery 事件</h3>
<h4 id="事件处理">事件处理</h4>
<h5 id="事件注册">事件注册</h5>
<p>单个事件注册：</p>
<figure data-type="image" tabindex="181"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200705091930160.png" alt="image-20200705091930160" loading="lazy"></figure>
<p>事件处理on</p>
<p>on()方法在匹配元素上绑定一个或多 个事件的事件处理函数</p>
<figure data-type="image" tabindex="182"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200705092211318.png" alt="image-20200705092211318" loading="lazy"></figure>
<figure data-type="image" tabindex="183"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200705092502309.png" alt="image-20200705092502309" loading="lazy"></figure>
<figure data-type="image" tabindex="184"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200705092857959.png" alt="image-20200705092857959" loading="lazy"></figure>
<p>在此之前有bind(, live() delegate0等方法来处理事件绑定或者事件委派,最新版本的请用on替代他们。</p>
<h5 id="事件处理-off-解绑事件">事件处理 off() 解绑事件</h5>
<p>off()方法可以移除通过on()方法添加的事件处理程序。</p>
<figure data-type="image" tabindex="185"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200705094548439.png" alt="image-20200705094548439" loading="lazy"></figure>
<p><mark>如果有的事件只想触发一次，可以使用one()来绑定事件。</mark></p>
<h5 id="自动触发事件-trigger">自动触发事件 trigger()</h5>
<p>有些事件希望自动触发比如轮播图自动播放功能跟击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件,不必鼠标点击触发。</p>
<figure data-type="image" tabindex="186"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200706074551404.png" alt="image-20200706074551404" loading="lazy"></figure>
<h4 id="事件对象">事件对象</h4>
<p>事件被触发，就会有事件对象的产生</p>
<figure data-type="image" tabindex="187"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200706074959544.png" alt="image-20200706074959544" loading="lazy"></figure>
<p>阻止默认行为: event.preventDefault(）或者return false<br>
阻止冒泡: event.stopPropagation()</p>
<h3 id="jquery-其他方法">jQuery 其他方法</h3>
<h4 id="jquery对象拷贝">jQuery对象拷贝</h4>
<p>如果想要把某个对象拷贝合并)给另外一个对象使用,此时可以使用$ .extend ()方法</p>
<figure data-type="image" tabindex="188"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200706075542235.png" alt="image-20200706075542235" loading="lazy"></figure>
<figure data-type="image" tabindex="189"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200706075824991.png" alt="image-20200706075824991" loading="lazy"></figure>
<figure data-type="image" tabindex="190"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200706080149237.png" alt="image-20200706080149237" loading="lazy"></figure>
<h4 id="jquery-多库共存">jQuery  多库共存</h4>
<p>jQuery使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">作</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">符</mi><mo separator="true">,</mo><mi mathvariant="normal">随</mi><mi mathvariant="normal">着</mi><mi>j</mi><mi>Q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">流</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi>j</mi><mi>s</mi><mi mathvariant="normal">库</mi><mi mathvariant="normal">也</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">这</mi></mrow><annotation encoding="application/x-tex">作为标示符,随着jQuery的流行，其他js库也会用这</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">符</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">随</span><span class="mord cjk_fallback">着</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">Q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">流</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">库</span><span class="mord cjk_fallback">也</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">这</span></span></span></span>作为标识符,这样意起使用会引起冲突。</p>
<figure data-type="image" tabindex="191"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200706081735633.png" alt="image-20200706081735633" loading="lazy"></figure>
<h4 id="jquery-插件">jQuery 插件</h4>
<p>jQuery功能比较有限,想要更复杂的特效效果,可以借助于jQuery插件完成。<br>
注意这些插件也是依赖于jQuery来完成的,所以必须要先引入jQuery文件,因此也称为jQuery插件。</p>
<figure data-type="image" tabindex="192"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200706082101260.png" alt="image-20200706082101260" loading="lazy"></figure>
<ol>
<li>图片懒加载</li>
<li>瀑布流</li>
<li>全屏滚动fullpage.js</li>
</ol>
<h3 id="jquery尺寸位置操作">jQuery尺寸位置操作</h3>
<h4 id="jquery-尺寸">jQuery 尺寸</h4>
<figure data-type="image" tabindex="193"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200706183714745.png" alt="image-20200706183714745" loading="lazy"></figure>
<p>●以上参数为空,则是获取相应值,返迥的是数字型。<br>
●如果参数为数字,则是修改相应值。<br>
●参数可以不必写单位。</p>
<h4 id="jquery-位置">jQuery 位置</h4>
<p>位置主要有三个：offset() 、position（）、scrollTop() /scrollLeft()</p>
<h5 id="offset-设置或获取元素偏移">offset () 设置或获取元素偏移</h5>
<figure data-type="image" tabindex="194"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200706184452758.png" alt="image-20200706184452758" loading="lazy"></figure>
<h5 id="position-获取元素偏移">position（） 获取元素偏移</h5>
<p>position()方法用于返回被选元素相对于带有定位的父级偏移坐标,如果父级都没有定位,则以文档为准。</p>
<h4 id="scrolltop-scrollleft-设置获取元素被卷去头部和左侧">scrollTop() /scrollLeft() 设置获取元素被卷去头部和左侧</h4>
<h2 id="八-javascript-进阶-202076-725">八. JavaScript 进阶  2020.7.6-7.25</h2>
<h3 id="面向对象编程介绍">面向对象编程介绍</h3>
<h4 id="1-俩大编程思想">1. 俩大编程思想</h4>
<h5 id="面向过程编程-pop">面向过程编程 POP</h5>
<p>面向过程就是分析出解决问题所需要的步骤,然后用函数把这些步骤一步一步实现,使用的时候再一个一个的依<br>
次调用就可以了。</p>
<p>举个栗子：把大象放进冰箱，分三步</p>
<h5 id="面向对象编程-oop">面向对象编程 OOP</h5>
<p>面向对象是把事务分解成为一个个对象,然后由对象之间分工与合作。</p>
<p>在面向对象程序开发思想中,每一个对象都是功能中心,具有明确分工。<br>
面向对象编程具有灵活、代码可复用、容易维护和开发的优点,更适合多人合作的大型软件项目。</p>
<p><mark>特性：封装、继承、多态</mark></p>
<figure data-type="image" tabindex="195"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200708081855695.png" alt="image-20200708081855695" loading="lazy"></figure>
<figure data-type="image" tabindex="196"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200708082027903.png" alt="image-20200708082027903" loading="lazy"></figure>
<h4 id="2-类和对象">2. 类和对象</h4>
<p>面向对象更贴近我们的实际生活，可以使用面向对象描述现实世界事物.但是事物分为具体的事物和抽象的事物</p>
<figure data-type="image" tabindex="197"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200708082438387.png" alt="image-20200708082438387" loading="lazy"></figure>
<p>面向对象的思维特点:</p>
<ol>
<li>抽取(抽象)对象共用的属性和行为组织(封装)成一 个类(模板)</li>
<li>对类进行实例化，获取类的对象</li>
</ol>
<p>面向对象编程我们考虑的是有哪些对象,按照面向对象的思维特点不断的创建对象使用对象指挥对象做事情.</p>
<h5 id="对象">对象</h5>
<p>现实生活中:万物皆对象,对象是一个具体的事物 ,看得见摸得着的实物。例如，一本书、一辆汽车、 一 个人<br>
可以是”对象”, -个数据库、一张网页、 -个与远程服务器的连接也可以是”对象”。<br>
在JavaScript中,对象是一组无序的相关属性和方法的集合 ,所有的事物都是对象,例如字符串、数值、数组、<br>
函数等。</p>
<figure data-type="image" tabindex="198"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200708082728798.png" alt="image-20200708082728798" loading="lazy"></figure>
<h5 id="类-class">类 class</h5>
<p>在ES6中新增加了类的概念,可以使用class关键字声明-个类,之后以这个类来实例化对象。<br>
类抽象了对象的公共部分,它泛指某一大类 ( class )</p>
<p>对象特指某一个，通过类实例化一个具体的对象</p>
<h5 id="创建类">创建类</h5>
<figure data-type="image" tabindex="199"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200708083024343.png" alt="image-20200708083024343" loading="lazy"></figure>
<h5 id="类constructor-构造函数">类constructor 构造函数</h5>
<p>constructor(）方法是类的构造函数(默认方法) ,用于传递参数返回实例对象,通过new命令生成对象实例时<br>
,自动调用该方法。如果没有显示定义，类内部会自动给我们创建一 个constructor( ）</p>
<p>(1)通过class关键字创建类，类名我们还是习惯性定义首字母大写<br>
(2)类里面有个constructor函数，可以接受传递过来的参数,同时返回实例对象<br>
(3) constructor 函数只要new生成实例时,就会自动调用这个函数，如果我们不写这个函数,类也会自动生成这个函数<br>
(4) 生成实例new不能省略<br>
(5)最后注意语法规范，创建类类名后面不要加小括号，生成实例类名后面加小括号，构造函数不需<br>
要加function</p>
<h5 id="类添加方法">类添加方法</h5>
<figure data-type="image" tabindex="200"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200708084457014.png" alt="image-20200708084457014" loading="lazy"></figure>
<h4 id="3-类的继承">3. 类的继承</h4>
<p>子类可以继承父类的一些属性和方法</p>
<h5 id="super-关键字">super 关键字</h5>
<p>super关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数,也可以调用父类的普通函数</p>
<p>1.继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的<br>
2.继承中，如果子类里面没有，就去查找父类有没有这个方法，如果有，就执行父类的这个方法(就近原<br>
则)</p>
<p><mark>super（）必须在子类this之前调用</mark></p>
<figure data-type="image" tabindex="201"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200708092454567.png" alt="image-20200708092454567" loading="lazy"></figure>
<h4 id="4-类和对象注意点">4. 类和对象注意点</h4>
<p>1.在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p>
<ol start="2">
<li>类里面的共有的属性和方法一定要加this使用 .</li>
<li>类里面的this指向问题（看谁调用，就指向谁）</li>
<li>constructor里面的this指向的是创建的实例对象</li>
</ol>
<h4 id="案例tab-栏切换">案例：tab 栏切换</h4>
<h3 id="构造函数和原型">构造函数和原型</h3>
<p>在典型的OOP的语言中(如Java) , 都存在类的概念,类就是对象的模板,对象就是类的实例,但在ES6之前，JS中并没引入类的概念。<br>
ES6,全称ECMAScript6.0 , 2015.06发版。但是目前浏览器的JavaScript是ES5版本,大多数高版本的浏览器也支持ES6 ,不过只实现了ES6的部分特性和功能。在ES6之前, 对象不是基于类创建的,而是用一种称为构建函数的特殊函数来定义对象和它们的特征。</p>
<h4 id="构造函数">构造函数</h4>
<p>构造函数是一种特殊的函数 ,主要来初始化对象,即为对象成员变量赋初始值,它总与new一起使用。我们可以把对象中一些公共的属性和方法抽取出来 ,然后封装到这个函数里面。</p>
<p>new在执行时会做四件事情:<br>
①在内存中创建一个 新的空对象。<br>
②让this指向这个新的对象。<br>
③执行构造函数里面的代码,给这个新对象添加属性和方法。<br>
④返回这个新对象(所以构造函数里面不需要return )。</p>
<p>举个栗子：</p>
<pre><code class="language-javascript">//构造函数创建对象
function Star(uname,age){
	this.name=name;
	this.age=age;
}
var ldh=new Star();
ldh.sing();
//静态成员 sex
Star.sex='man';
</code></pre>
<h5 id="实例成员和静态成员">实例成员和静态成员</h5>
<p>实例成员：构造函数内部通过this添加的成员 uname,age,实例成员只能通过实例化的对象（ldh）来访问</p>
<p>静态成员：在构造函数本身上添加的成员(sex)</p>
<h5 id="构造函数的问题浪费内存">构造函数的问题：浪费内存</h5>
<figure data-type="image" tabindex="202"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200711090954008.png" alt="image-20200711090954008" loading="lazy"></figure>
<h5 id="构造函数原型prototype"><mark>构造函数原型prototype</mark></h5>
<p>构造函数通过原型分配的函数是所有对象共享的</p>
<p>JavaScript规定,每一个构造函数都有一个 prototype属性,指向另一个对象。 注意这个prototype就是一个对象,这个对象的所有属性和方法,都会被构造函数所拥有。</p>
<p>我们可以把那些不变的方法,直接定义在prototype对象上,这样所有对象的实例就可以共享这些方法。</p>
<p><mark>公共属性定义到构造函数里，公共的方法放到原型上</mark></p>
<h5 id="对象原型-__proto__">对象原型 <code>__proto__</code></h5>
<p>对象都会有一个属性<code>__proto__</code>指向构造函数的 prototype原型对象,之所以我们对象可以使用构造函数prototype原型对象的属性和方法,就是因为对象有<code>__proto__</code>原型的存在。</p>
<p>方法查找规则：</p>
<ol>
<li>先看实例化对象上有没有目标方法，若有，则执行该目标方法</li>
<li>若没有，则去构造函数原型对象prototype 查找目标方法</li>
</ol>
<figure data-type="image" tabindex="203"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200711093448379.png" alt="image-20200711093448379" loading="lazy"></figure>
<h5 id="构造函数-constructor">构造函数  constructor</h5>
<p>对象原型(_ proto_ ) 和构造函数( prototype )原型对象里面都有一个属性constructor属性, constructor我们称为构造函数,因为它指回构造函数本身。</p>
<h5 id="三者关系">三者关系</h5>
<figure data-type="image" tabindex="204"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200711153417525.png" alt="image-20200711153417525" loading="lazy"></figure>
<h5 id="原型链">原型链</h5>
<figure data-type="image" tabindex="205"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200711154312096.png" alt="image-20200711154312096" loading="lazy"></figure>
<h5 id="javascript的成员查找机制">JavaScript的成员查找机制</h5>
<figure data-type="image" tabindex="206"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200711155357430.png" alt="image-20200711155357430" loading="lazy"></figure>
<h5 id="原型对象指向this">原型对象指向this</h5>
<ol>
<li>在构造函数中，里面this指向的是实例对象 ldh</li>
<li>原型对象函数里面的this 指向的是实例对象 ldh</li>
</ol>
<h5 id="扩展内置对象">扩展内置对象</h5>
<p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能</p>
<h4 id="继承">继承</h4>
<p>ES6之前并没有给我们提供extends继承。我们可以通过构造函数+原型对象模拟实现继承,被称为组合继承。</p>
<h5 id="call">call ()</h5>
<p>call () 调用函数，并且修改函数运行时的this指向</p>
<pre><code class="language-javascript">function Father(uname,age){
	this.uname=uname; //this 指向父构造函数的实例对象
	this.age=age;
}
function Son(uname,age){
	Father.call(this,uname,age);// this指向子构造函数的实例对象 
}
var son=new Son('ww',18);
</code></pre>
<h5 id="利用原型对象继承父类型方法">利用原型对象继承父类型方法</h5>
<pre><code class="language-javascript">function Father(uname,age){
	this.uname=uname; //this 指向父构造函数的实例对象
	this.age=age;
}
Father.prototype.money=function(){
    console.log(10000000);
}
function Son(uname,age){
	Father.call(this,uname,age);// this指向子构造函数的实例对象 ,call 调用构造函数
}
//Son.prototype=Father.prototype; //直接赋值会有问题，如果修改子原型对象，父原型对象跟着变化
Son.prototype=new Father();
Son.prototype.constructor=Son; //如果利用对象的形式修改了原型对象，别忘了利用constructor 指回原来的构造函数
Son.prototype.exam=function(){
    console.log(&quot;exam&quot;);
}
var son=new Son('ww',18);
</code></pre>
<p><mark>如果利用对象的形式修改了原型对象，别忘了利用constructor 指回原来的构造函数</mark></p>
<figure data-type="image" tabindex="207"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200712101012002.png" alt="image-20200712101012002" loading="lazy"></figure>
<h5 id="es5-新增方法">ES5 新增方法</h5>
<h6 id="数组方法">数组方法</h6>
<p>迭代：forEach() 、 map() 、filter () 、some() 、every()</p>
<figure data-type="image" tabindex="208"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200712101847080.png" alt="image-20200712101847080" loading="lazy"></figure>
<figure data-type="image" tabindex="209"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200712102136879.png" alt="image-20200712102136879" loading="lazy"></figure>
<figure data-type="image" tabindex="210"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200712102530565.png" alt="image-20200712102530565" loading="lazy"></figure>
<h6 id="字符串方法-trim">字符串方法  trim()</h6>
<figure data-type="image" tabindex="211"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200718085200701.png" alt="image-20200718085200701" loading="lazy"></figure>
<h6 id="对象方法">对象方法</h6>
<p>Object.keys() 用于获取对象自身所有属性</p>
<figure data-type="image" tabindex="212"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200718085726552.png" alt="image-20200718085726552" loading="lazy"></figure>
<figure data-type="image" tabindex="213"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200718091259476.png" alt="image-20200718091259476" loading="lazy"></figure>
<h3 id="函数进阶">函数进阶</h3>
<h4 id="函数的定义和调用">函数的定义和调用</h4>
<h5 id="1-函数的定义">1. 函数的定义</h5>
<figure data-type="image" tabindex="214"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200719082851141.png" alt="image-20200719082851141" loading="lazy"></figure>
<p>函数也属于对象</p>
<figure data-type="image" tabindex="215"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200719083115743.png" alt="image-20200719083115743" loading="lazy"></figure>
<h5 id="2-函数的调用">2. 函数的调用</h5>
<ul>
<li>普通函数</li>
<li>对象的方法</li>
<li>构造函数</li>
<li>绑定事件函数</li>
<li>定时器函数</li>
<li>立即执行函数</li>
</ul>
<pre><code class="language-javascript">function fn(){
	console.log('top 1');
}
fn()/fn.call(); //普通函数

var o={
    saiyes:function(){
        console.log('i do ');
    }
}
o.saiyes();   //对象中的方法

function Star();
new Star();  //构造函数new一下

btn.onclick=function() {
    //绑定事件函数
}

setInterval(function(){},1000) //定时器函数

(function（){
    console.log('sai yes');//立即执行函数
}）()
</code></pre>
<h4 id="this">this</h4>
<h5 id="this的指向">this的指向</h5>
<p>this 的指向，是当调用函数的时候确定的。调用方式的不同决定了this的指向不同，一般指向调用者</p>
<figure data-type="image" tabindex="216"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200719084733851.png" alt="image-20200719084733851" loading="lazy"></figure>
<h5 id="改变函数内部this指向">改变函数内部this指向</h5>
<h6 id="call-2">call()</h6>
<figure data-type="image" tabindex="217"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200719085311716.png" alt="image-20200719085311716" loading="lazy"></figure>
<h6 id="apply">apply ()</h6>
<figure data-type="image" tabindex="218"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200719094217520.png" alt="image-20200719094217520" loading="lazy"></figure>
<h6 id="bind">bind ()</h6>
<p>bind() 不会调用函数，但是能改变this指向</p>
<figure data-type="image" tabindex="219"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200719094423985.png" alt="image-20200719094423985" loading="lazy"></figure>
<h6 id="区别">区别</h6>
<figure data-type="image" tabindex="220"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200719100927230.png" alt="image-20200719100927230" loading="lazy"></figure>
<h4 id="严格模式">严格模式</h4>
<p>JavaScript除了提供正常模式外,还提供了严格模式( strict mode )。ES5 的严格模式是采用具有限制性<br>
JavaScript变体的一种方式,即在严格的条件下运行JS代码。</p>
<h5 id="开启严格模式">开启严格模式</h5>
<p>严格模式可以应用到整个脚本或个别函数中。因此在使用时,我们可以将严格模式分为为脚本开启严格模式和<br>
为函数开启严格模式两种情况。</p>
<h6 id="脚本开启严格模式">脚本开启严格模式</h6>
<p>为整个脚本文件开启严格模式,需要在所有语句之前放一个特定语句&quot;use strict&quot; ;(或'use strict’ 😉。</p>
<h6 id="函数开启严格模式">函数开启严格模式</h6>
<p>要给某个函数开启严格模式,需要把&quot;use strict&quot; ; (或'use strict';)声明放在函数体所有语句之前。</p>
<h5 id="严格模式中的变化">严格模式中的变化</h5>
<h6 id="变量规定">变量规定</h6>
<figure data-type="image" tabindex="221"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200720084350129.png" alt="image-20200720084350129" loading="lazy"></figure>
<h6 id="严格模式下this指向的问题">严格模式下this指向的问题</h6>
<figure data-type="image" tabindex="222"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200720084913661.png" alt="image-20200720084913661" loading="lazy"></figure>
<h6 id="函数变化">函数变化</h6>
<figure data-type="image" tabindex="223"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200720085231236.png" alt="image-20200720085231236" loading="lazy"></figure>
<h4 id="高阶函数">高阶函数</h4>
<p>高阶函数是对其他函数进行操作的函数,它接收函数作为参数或将函数作为返回值输出。</p>
<h4 id="闭包">闭包</h4>
<h5 id="变量作用域">变量作用域</h5>
<figure data-type="image" tabindex="224"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200720090232811.png" alt="image-20200720090232811" loading="lazy"></figure>
<h5 id="闭包定义">闭包定义</h5>
<p><mark>闭包是有权访问另一个函数作用域中变量的函数</mark></p>
<h5 id="闭包案例">闭包案例</h5>
<h6 id="循环注册点击事件">循环注册点击事件</h6>
<p>利用闭包方式得到小li 的索引号</p>
<img src="file://C:/Users/lenovo/Documents/Gridea/post-images/bibao.png" alt="bibao" style="zoom: 80%;" />
<h4 id="递归">递归</h4>
<h5 id="递归定义函数内部可以调用自己本身">递归定义：函数内部可以调用自己本身</h5>
<figure data-type="image" tabindex="225"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200720102641522.png" alt="image-20200720102641522" loading="lazy"></figure>
<h5 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h5>
<p>1.浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用<br>
2.深拷贝拷贝多层,每一级别的数据都会拷贝.</p>
<p>object.assign(target,sources)</p>
<h3 id="正则表达式">正则表达式</h3>
<p>正则表达式( Regular Expression )是用于匹配字符串中字符组合的模式。在JavaScript中,正则表达式也是对象。</p>
<p>作用：验证表单</p>
<figure data-type="image" tabindex="226"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200722082453853.png" alt="image-20200722082453853" loading="lazy"></figure>
<h4 id="正则表达式在javascript中的使用">正则表达式在JavaScript中的使用</h4>
<h5 id="创建正则表达式">创建正则表达式</h5>
<p>通过RegExp 对象的构造函数创建</p>
<figure data-type="image" tabindex="227"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200722083045143.png" alt="image-20200722083045143" loading="lazy"></figure>
<p>利用字面量创建 正则表达式</p>
<figure data-type="image" tabindex="228"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200722083149417.png" alt="image-20200722083149417" loading="lazy"></figure>
<h5 id="测试正则表达式-test">测试正则表达式 test</h5>
<p>test()正则对象方法,用于检测字符是否符合该规则,该对象会返回true或false ,其参数是测试字符串。</p>
<figure data-type="image" tabindex="229"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200722083439415.png" alt="image-20200722083439415" loading="lazy"></figure>
<p><mark>/   /里面只要包含，返回的是true</mark></p>
<h4 id="正则表达式中的特殊字符">正则表达式中的特殊字符</h4>
<h5 id="正则表达式的组成">正则表达式的组成</h5>
<figure data-type="image" tabindex="230"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200722083750007.png" alt="image-20200722083750007" loading="lazy"></figure>
<figure data-type="image" tabindex="231"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200722083830136.png" alt="image-20200722083830136" loading="lazy"></figure>
<h5 id="边界符">边界符</h5>
<figure data-type="image" tabindex="232"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200722084209270.png" alt="image-20200722084209270" loading="lazy"></figure>
<p><mark>正则表达式里面不需要加引号。</mark></p>
<p>字符类：[  ]表示有一系列字符可供选择，只能匹配其中一个就可以,所有可供选择的放在方括号里</p>
<pre><code class="language-javascript">var rg=/[abc]/; //只要包含有a或者有b或者有c 都返回为true

var rg1=/^[abc]$/; //三选一，只能是a或者b或者c

var rg=/^[a-z]$/; //26个小写字母任何一个字母返回为true  -范围符号

var rg=/^[a-zA-Z]$/; //26个字母任何一个字母(大小写)返回为true 

var rg=/^[^a-zA-Z]$/; //[]里的^意为取反。不能包含字母
</code></pre>
<h5 id="量词符">量词符</h5>
<p>量词符用来设定某个模式出现的次数</p>
<figure data-type="image" tabindex="233"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200722092706359.png" alt="image-20200722092706359" loading="lazy"></figure>
<pre><code class="language-javascript">var rg=/^[^a-zA-Z0-9_-]{6,16}$/; //{}中不能有空格 
</code></pre>
<h5 id="括号总结">括号总结</h5>
<figure data-type="image" tabindex="234"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200722095609724.png" alt="image-20200722095609724" loading="lazy"></figure>
<h5 id="预定义类">预定义类</h5>
<p>预定义类指的是某些常见模式的特殊写法</p>
<figure data-type="image" tabindex="235"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200723084907781.png" alt="image-20200723084907781" loading="lazy"></figure>
<p>正则里面的或者符号：|</p>
<h5 id="replace-替换">replace 替换</h5>
<figure data-type="image" tabindex="236"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200723094748440.png" alt="image-20200723094748440" loading="lazy"></figure>
<figure data-type="image" tabindex="237"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200723095158030.png" alt="image-20200723095158030" loading="lazy"></figure>
<p><mark>弹幕屏蔽应用</mark></p>
<pre><code class="language-javascript">var str = 'WW是WW首富'
var reg11 = /WW/g
console.log(str.replace(reg11, function(newstr) {//获取到要替换的值(ww)
    console.log(newstr);
    var result = '';
    for (var i = 0; i &lt; newstr.length; i++) {
        result += '*';
    }
    return result;
}));
</code></pre>
<p>正则表达式的参数</p>
<figure data-type="image" tabindex="238"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200723095253562.png" alt="image-20200723095253562" loading="lazy"></figure>
<h3 id="es6">ES6</h3>
<p>ES的全称是ECMAScript ,它是由ECMA国际标准化组织,制定的一项脚本语言的标准化规范。ES6实际上是一个泛指，泛指ES2015及后续的版本。</p>
<h4 id="es6-新增方法">ES6 新增方法</h4>
<h5 id="let">let</h5>
<figure data-type="image" tabindex="239"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200725084302816.png" alt="image-20200725084302816" loading="lazy"></figure>
<p>防止循环变量变成全局变量</p>
<figure data-type="image" tabindex="240"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200725091604049.png" alt="image-20200725091604049" loading="lazy"></figure>
<h2 id="九vue-框架学习-2020724-821">九.vue 框架学习 2020.7.24-8.21</h2>
<p>Vue :渐进式JavaScript框架</p>
<p>声明式渲染→组件系统客户端路由&gt;集中式状态管理- &gt;项目构建</p>
<p>●易用: 熟悉HTML、CSS、JavaScript知识后 ,可快速手Vue<br>
●灵活:在一个库和一鯇整框架之间自如伸缩<br>
●高效: 20kB运行大小,超快虚拟DOM</p>
<h3 id="vue-的基本使用">vue 的基本使用</h3>
<figure data-type="image" tabindex="241"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200724085618786.png" alt="image-20200724085618786" loading="lazy"></figure>
<figure data-type="image" tabindex="242"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200724085706503.png" alt="image-20200724085706503" loading="lazy"></figure>
<figure data-type="image" tabindex="243"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200724090042672.png" alt="image-20200724090042672" loading="lazy"></figure>
<h3 id="模板语法">模板语法</h3>
<h4 id="前端渲染方式">前端渲染方式</h4>
<figure data-type="image" tabindex="244"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/image-20200724090355837.png" alt="image-20200724090355837" loading="lazy"></figure>
<h2 id="十ajax-学习">十.AJAX 学习</h2>
<h3 id="ajax-基础">AJAX 基础</h3>
<p>Ajax  是一种异步的从服务器获取数据的方法，在不刷新整个页面的情况下可以做到局部更新数据</p>
<p>实例： 百度搜索，重名检测，更换验证码，分页加载，京东页面加载。。。</p>
<p>优点： 传统的页面获取新数据需要刷新整个页面，等待时间比较长；但这种技术能够向服务器请求额外的数据而无须卸载页面(即刷新) ，会带来更好的用户体验。</p>
<h3 id="get和post区别">get和post区别</h3>
<p>get:  请求参数拼接到url后，例如 www.baidu.com?wd=iphone&amp;userid=001&amp;sex=1   ,从浏览器上输入一个网址就是使用的get方式请求数据，get一般用于获取数据，且传给服务器的数据量(参数)很小,最多只有几 KB。</p>
<p>post： 请求参数不在url中，而是拼接在 <body>标签中(请求体)，post相对于get方法主要是可以向服务器提交更多的数据，上传文件一般使用post方式。</p>
<h3 id="json">JSON</h3>
<h4 id="json-规则">JSON 规则</h4>
<p>使用Ajax和后台进行交互，常见的格式是: JSON     , XML(使用较少)<br>
JSON 指的是    JavaScript 对象表示法（JavaScript Object Notation）<br>
JSON 格式，是一种特殊string类型，由若干个键值对构成，和对象结构很像例如：</p>
<p>1.多个键值对构成的JSON字符串<br>
&quot; {'name':'mrwang','address':qingdao,'job':'coder'} &quot;    //所有的key都是字符串<br>
2.数组形式的<br>
'[{&quot;name&quot; : &quot;a&quot;,&quot;age&quot; : 1},{&quot;name&quot; : &quot;b&quot;,&quot;age&quot; : 2}]';<br>
3.嵌套结构<br>
&quot; {'person':{},'name':&quot;mrwang&quot;} &quot;<br>
注意：  json格式的key必需是字符串，且value不可以为undefined<br>
JSON文件构建： 使用webStorm构建   xx.json, webStorm会提供语法检查<br>
JSON在线转换网站：  json.cn       ，标准的JSON的key都是使用双引号包裹</p>
<h4 id="json-与对象转换">JSON 与对象转换</h4>
<p>ES5原生支持JSON转换：<br>
<mark>把字符串转换为对象 :      JSON.parse(obj)               返回对象</mark><br>
把对象转换为字符串:        JSON.stringify(jsonstr)           返回字符串<br>
特点： 使用简单，但IE8及以下不支持；在做移动端的时候，可以放心使用</p>
<h4 id="eval">eval</h4>
<p>eval是一个可以 执行 js字符串代码的方法,并返回相应的结果。</p>
<pre><code class="language-javascript">var  str = &quot;alert('A');alert('B');alert('C');&quot;;
eval(str); //或者  window.eval()

var  sum = eval(&quot;2 + 3&quot;);
 alert(sum);
</code></pre>
<p>使用eval把json字符串转换为对象 eval(   ({name:ssss})  )</p>
<pre><code class="language-javascript">var  obj = eval(   &quot;(&quot;  +  jsonstr  + &quot;)&quot;   );
</code></pre>
<p><mark>注意： 切勿大量使用 eval方法，eval不安全而且不利于浏览器优化代码</mark></p>
<h3 id="封装ajax"><mark>封装ajax</mark></h3>
<pre><code class="language-javascript">function ajax(method,url,isbol,successfulFn){
	var rex=new XMLHttpRequest()
	rex.onreadystatechange=function(){
		if(rex.readyState==4&amp;&amp;rex.status==200){
			successfulFn(rex.responseText)
		}
	}
	rex.open(method,url,isbol)
	rex.send()
}
ajax('get','text.json',true,function(res){
	document.write(res)
	var objs=JSON.parse(res)
	console.log(objs)
})
			
</code></pre>
<p><mark>对ajax 生成的元素js操作需放在ajax函数里</mark>,案例--京东电脑</p>
<hr>
<h1 id="移动端开发">移动端开发</h1>
<h2 id="一-flex-伸缩布局-202048-410">一. Flex 伸缩布局  2020.4.8-4.10</h2>
<h3 id="1视口-viewport">1.视口  viewport</h3>
<p>视口就是浏览器显示当前页面内容的屏幕区域。视口可以分为布局视口、视觉视口、<mark>理想视口</mark></p>
<h4 id="11-布局视口-layout-viewport">1.1 布局视口  layout viewport</h4>
<p>●一般移动设备的浏览器都默认设置了一个布局视口 ,用于解决早期的PC端页面在手机上显示的问题。<br>
●<code>iOS</code>, <code>Android</code>基本都将这个视口分辨率设置为<code>980px</code> ,所以PC上的网页大多都能在手机上呈现,只不<br>
过元素看上去很小,一般默认可以通过手动缩放网页。</p>
<figure data-type="image" tabindex="245"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586311833048.png" alt="1586311833048" loading="lazy"></figure>
<h4 id="12-视觉视口-visual-viewport">1.2 视觉视口  visual viewport</h4>
<ul>
<li>用户正在看到的网站的区域 ，注意：<mark>网站区域</mark></li>
<li>可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口保持原来的宽度</li>
</ul>
<figure data-type="image" tabindex="246"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586311863721.png" alt="1586311863721" loading="lazy"></figure>
<h4 id="13-理想视口-ideal-viewport">1.3 理想视口  ideal viewport</h4>
<ul>
<li>为了网站在移动端最理想的浏览和宽度而设定</li>
<li>理想视口，对设备来说，是最理想的视口尺寸</li>
<li>需要手动添写meta视口标签通知浏览器操作</li>
<li>meta视口标签的主要目的：布局视口的宽度应和理想视口的宽度一致，简单来说就是设备有多宽，我的布局视口有多宽</li>
</ul>
<h3 id="2-meta-视口标签">2. meta  视口标签</h3>
<pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0,
    minimum-sacle=1.0,user-scalable=no&quot;&gt;
</code></pre>
<figure data-type="image" tabindex="247"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586335693141.png" alt="1586335693141" loading="lazy"></figure>
<h3 id="3-二倍图">3. 二倍图</h3>
<h4 id="31-多倍图">3.1 多倍图</h4>
<figure data-type="image" tabindex="248"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586403480917.png" alt="1586403480917" loading="lazy"></figure>
<figure data-type="image" tabindex="249"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586403489038.png" alt="1586403489038" loading="lazy"></figure>
<h4 id="32-背景缩放-background-size">3.2  背景缩放  background-size</h4>
<p>background-size 属性规定背景图像的尺寸</p>
<pre><code class="language-html">background-size:背景图片宽度 背景图片高度；
</code></pre>
<figure data-type="image" tabindex="250"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586403848765.png" alt="1586403848765" loading="lazy"></figure>
<h3 id="4-单独移动端页面主流">4.  单独移动端页面（主流）</h3>
<p>通常情况下，网站域名前面加m(mobile)可以打开移动端。通过判断设备，如果是移动端设备打开，则跳转移动端页面</p>
<h3 id="5-响应式兼容pc移动端">5. 响应式兼容PC移动端</h3>
<h3 id="6移动端-技术解决方案">6.移动端 技术解决方案</h3>
<h4 id="61-css-初始化-normalizecss">6.1 css 初始化  <code>normalize.css</code></h4>
<figure data-type="image" tabindex="251"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586404657288.png" alt="1586404657288" loading="lazy"></figure>
<p>官网：<a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></p>
<h4 id="62-css3-盒子模型box-sizing">6.2   CSS3 盒子模型box-sizing</h4>
<figure data-type="image" tabindex="252"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586410929396.png" alt="1586410929396" loading="lazy"></figure>
<figure data-type="image" tabindex="253"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586410937545.png" alt="1586410937545" loading="lazy"></figure>
<figure data-type="image" tabindex="254"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586410943253.png" alt="1586410943253" loading="lazy"></figure>
<h4 id="63-特殊样式">6.3  特殊样式</h4>
<figure data-type="image" tabindex="255"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586574008032.png" alt="1586574008032" loading="lazy"></figure>
<h3 id="7-移动端常见布局">7. 移动端常见布局</h3>
<h4 id="71-移动端技术选型">7.1  移动端技术选型</h4>
<figure data-type="image" tabindex="256"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586574144267.png" alt="1586574144267" loading="lazy"></figure>
<h5 id="711-流式布局百分比布局">7.1.1 流式布局（百分比布局）</h5>
<ul>
<li>流式布局，百分比布局，也称非固定像素布局</li>
<li>通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充</li>
<li>流式布局方式是移动web开发使用的比较常见的布局方式</li>
<li>max-width 最大宽度</li>
<li>min-width  最小宽度</li>
</ul>
<p><mark>案例：京东手机端首页</mark></p>
<h5 id="712-flex布局">7.1.2  flex布局</h5>
<h3 id="8flex-布局">8.flex 布局</h3>
<h4 id="1特点">1.特点</h4>
<ul>
<li>
<p>操作方便，布局极为简单，移动端应用广泛</p>
</li>
<li>
<p>PC端浏览器支持情况较差</p>
</li>
<li>
<p>IE11或更低版本，不支持或仅部分支持</p>
</li>
</ul>
<h4 id="2原理">2.原理</h4>
<p>flex 是flexible box,译为弹性布局，用来为盒装模型提供最大的灵活性，任何一个容器都可以指定为flex布局</p>
<ul>
<li>当我们为父盒子指定为flex布局以后，子元素 的float、clear和vertical-align属性将失效</li>
<li>伸缩布局=弹性布局=伸缩盒布局=弹性盒布局=flex布局</li>
</ul>
<p><mark>总结：通过给父盒子添加flex属性，来控制盒子的位置和排列方式</mark>（子容器/flex项目可以横向排列或者竖向排列）</p>
<h4 id="3常用父项属性">3.常用父项属性</h4>
<p>flex- direction :设置主轴的方向<br>
justify-content :设置主轴上的子元素排列方式<br>
flex-wrap :设置子元素是否换行<br>
align-content :设置侧轴上的子元素的排列方式(多行)<br>
align- items :设置侧轴上的子元素排列方式(单行)<br>
flex-flow :复合属性,相当于同时设置了flex direction和flex-wrap</p>
<hr>
<h5 id="1-flex-direction-属性决定主轴的方向即项目的排列方向">1. flex-direction 属性决定主轴的方向（即项目的排列方向）</h5>
<p><mark>注：主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的是侧轴。子元素是跟主轴来排列的</mark></p>
<figure data-type="image" tabindex="257"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586912678353.png" alt="1586912678353" loading="lazy"></figure>
<h5 id="2-justify-content-设置主轴上的子元素排列方式">2 .justify-content :设置主轴上的子元素排列方式</h5>
<p>justify-content属性定义了项目在主轴上的对齐方式（<strong>注：使用这个属性前一定确定好主轴是哪个</strong>）</p>
<figure data-type="image" tabindex="258"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586913418185.png" alt="1586913418185" loading="lazy"></figure>
<h5 id="3flex-wrap-设置子元素是否换行">3.flex-wrap :设置子元素是否换行</h5>
<p>默认情况下，项目都排在一条线上。flew-wrap属性定义，felx布局中默认是不换行的</p>
<figure data-type="image" tabindex="259"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586914506942.png" alt="1586914506942" loading="lazy"></figure>
<h5 id="4-align-items-设置侧轴上的子元素排列方式单行">4. align- items :设置侧轴上的子元素排列方式(单行)</h5>
<p>控制子项在侧轴（默认是y轴）上的排列方式 在子项为单项的时候使用</p>
<figure data-type="image" tabindex="260"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586914753884.png" alt="1586914753884" loading="lazy"></figure>
<h5 id="5-align-content-设置侧轴上的子元素的排列方式多行">5. align-content :设置侧轴上的子元素的排列方式(多行)</h5>
<p>设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况（多行)，在单行下是没有效果滴</p>
<figure data-type="image" tabindex="261"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586950822887.png" alt="1586950822887" loading="lazy"></figure>
<p>align-content和align-items 的区别</p>
<ul>
<li>
<p>align-item适应于单行情况下，只有上对齐、下对齐和居中拉伸</p>
</li>
<li>
<p>align-content适应于多行（换行）情况下，可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值</p>
</li>
</ul>
<h5 id="6flex-flow-复合属性">6.flex-flow :复合属性</h5>
<figure data-type="image" tabindex="262"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1586956962601.png" alt="1586956962601" loading="lazy"></figure>
<h4 id="4常用子项属性">4.常用子项属性</h4>
<h5 id="41-flex-属性">4.1  flex 属性</h5>
<figure data-type="image" tabindex="263"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587001088867.png" alt="1587001088867" loading="lazy"></figure>
<h5 id="42-align-self-控制子项在侧轴上的排列方式">4.2  align-self 控制子项在侧轴上的排列方式</h5>
<p>align-self属性允许单个项目有其他项目不样的对齐方式,可覆盖align-items属性。默认值为auto ,示继承父元素的align-items属性,如果没有元素,则等同于stretch。</p>
<h5 id="43-order-属性定义项目的排列顺序">4.3  order 属性定义项目的排列顺序</h5>
<p>数值越小，排列越靠前，默认是0.</p>
<p>注：和z-index不一样</p>
<h2 id="二-rem-适配布局">二. rem 适配布局</h2>
<h3 id="1-rem-基础">1. rem 基础</h3>
<figure data-type="image" tabindex="264"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587435984784.png" alt="1587435984784" loading="lazy"></figure>
<p><mark>优势：通过修改HTML里面的文字大小来改变页面中元素的大小可以整体控制</mark></p>
<h3 id="2-媒体查询">2. 媒体查询</h3>
<h4 id="21媒体查询定义">2.1媒体查询定义</h4>
<p>媒体查询( Media Query )是CSS3新语法。</p>
<figure data-type="image" tabindex="265"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587436528311.png" alt="1587436528311" loading="lazy"></figure>
<h4 id="22-语法规范">2.2 语法规范</h4>
<figure data-type="image" tabindex="266"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587436648863.png" alt="1587436648863" loading="lazy"></figure>
<h5 id="1-mediatype-媒体类型">1. mediatype  媒体类型</h5>
<figure data-type="image" tabindex="267"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587436767807.png" alt="1587436767807" loading="lazy"></figure>
<h5 id="2-关键字">2.   关键字</h5>
<figure data-type="image" tabindex="268"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587436868917.png" alt="1587436868917" loading="lazy"></figure>
<h5 id="3-媒体特性">3. 媒体特性</h5>
<figure data-type="image" tabindex="269"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587436918135.png" alt="1587436918135" loading="lazy"></figure>
<h5 id="4-引入资源">4. 引入资源</h5>
<p>当样式比较繁多的时候,我们可以针对不同的媒体使用不同stylesheets (样式表)。</p>
<p>原理,就是直接在link中判断设备的尺寸,然后引用不同的css文件。</p>
<figure data-type="image" tabindex="270"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587781811160.png" alt="1587781811160" loading="lazy"></figure>
<h3 id="3-less">3. less</h3>
<h4 id="31-维护css的弊端">3.1  维护css的弊端</h4>
<figure data-type="image" tabindex="271"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587782055398.png" alt="1587782055398" loading="lazy"></figure>
<h4 id="32-less-基础">3.2  less 基础</h4>
<h5 id="1-介绍">1. 介绍</h5>
<figure data-type="image" tabindex="272"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587782385139.png" alt="1587782385139" loading="lazy"></figure>
<h5 id="2-less-变量">2. less 变量</h5>
<figure data-type="image" tabindex="273"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587783342994.png" alt="1587783342994" loading="lazy"></figure>
<h5 id="3-less-编译">3. less 编译</h5>
<p>本质上, Less包含-自定义的语法及-个解析器,用户根据这些语法定义自己的样式规则,这些规则最终会通过解析器,编译生成对应的CSS文件。<br>
所以,我们需要把我们的less文件,编译生成为css文件,这样我们的html页面才能使用。</p>
<h5 id="4-less-嵌套">4. less 嵌套</h5>
<p>less嵌套 ： 子元素样式直接写在父元素里面</p>
<figure data-type="image" tabindex="274"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587815493170.png" alt="1587815493170" loading="lazy"></figure>
<figure data-type="image" tabindex="275"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587815652296.png" alt="1587815652296" loading="lazy"></figure>
<h5 id="5-less-运算">5. <mark>less 运算</mark></h5>
<p>任何数字、颜色或者变量都可以参与运算。less提供了加减乘除算数运算</p>
<figure data-type="image" tabindex="276"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587816025554.png" alt="1587816025554" loading="lazy"></figure>
<figure data-type="image" tabindex="277"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587816079593.png" alt="1587816079593" loading="lazy"></figure>
<h3 id="4-rem-适配方案">4. rem  适配方案</h3>
<p>1.让一些不能等比自适应的元素,达到当设备尺寸发生改变的时候,等比例适配当前设备。<br>
2.使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位,当html字体大小变化，元素尺寸也会发生变化,从而达到等比缩放的适配。</p>
<h5 id="1-rem-实际开发适配方案">1. rem 实际开发适配方案</h5>
<figure data-type="image" tabindex="278"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587816470594.png" alt="1587816470594" loading="lazy"></figure>
<h5 id="2-rem-适配方案技术使用">2. rem 适配方案技术使用</h5>
<figure data-type="image" tabindex="279"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587816523496.png" alt="1587816523496" loading="lazy"></figure>
<figure data-type="image" tabindex="280"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587956275015.png" alt="1587956275015" loading="lazy"></figure>
<figure data-type="image" tabindex="281"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1588235723539.png" alt="1588235723539" loading="lazy"></figure>
<h2 id="三响应式布局bootstrap-2020128-25">三.响应式布局Bootstrap    2020.1.28-2.5</h2>
<h3 id="1列嵌套">1.列嵌套</h3>
<p>​</p>
<h3 id="2列偏移">2.列偏移</h3>
<h4 id="右侧偏移col-lg-offest-偏移的份数">右侧偏移,col-lg-offest-#，#偏移的份数</h4>
<h3 id="3列排序">3.列排序</h3>
<h4 id="通过使用col-lg-push-和col-lg-pull-类就可以改变列的顺序右侧往左拉pull左侧push退">通过使用.col-lg-push-#和.col-lg-pull-#类就可以改变列的顺序，右侧往左拉pull，左侧push退</h4>
<h3 id="4响应式工具">4.响应式工具</h3>
<h4 id="工具类针对不同的设备大小展示或隐藏页面内容">工具类针对不同的设备大小展示或隐藏页面内容</h4>
<p>​</p>
<figure data-type="image" tabindex="282"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1580440319261.png" alt="580440319261" loading="lazy"></figure>
<h4 id="相反visible-xs-visible-sm显示页面内容">相反，visible-xs  ,visible-sm，，，显示页面内容</h4>
<h3 id="5阿里百秀项目实战">5.阿里百秀项目实战</h3>
<h1 id="开发经验-950px310px">开发经验   <code>950px*310px</code></h1>
<h3 id="1清除元素的默认内外边距">1.<mark>清除元素的默认内外边距</mark></h3>
<figure data-type="image" tabindex="283"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582356033472.png" alt="1582356033472" loading="lazy"></figure>
<pre><code class="language-HTML">*{
 padding：0；
 margin：0；
}
</code></pre>
<p>注意:<br>
●行内元素为了照顾兼容性，尽量只设置左右内外边距， 不要设置上下内外边距。</p>
<h3 id="2去掉列表默认样式">2.去掉列表默认样式</h3>
<figure data-type="image" tabindex="284"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582425223117.png" alt="1582425223117" loading="lazy"></figure>
<h3 id="3css书写规范">3.css书写规范</h3>
<h4 id="31空格规范">3.1空格规范</h4>
<p><mark>选择器与{之间必须包含空格</mark></p>
<p><mark>属性名与之后的:之间不允许包含空格，: 与属性值之间必须包含空格。</mark></p>
<h4 id="32-选择器规范">3.2 选择器规范</h4>
<p>并集选择器，每个选择器另起一行</p>
<p>一般情况情况下，选择器的嵌套层级应不大于3级，位置靠后的限定条件应尽可能精确。</p>
<figure data-type="image" tabindex="285"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582440092017.png" alt="1582440092017" loading="lazy"></figure>
<h3 id="4导航栏">4.导航栏</h3>
<figure data-type="image" tabindex="286"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582531537809.png" alt="1582531537809" loading="lazy"></figure>
<p>排列整体用li</p>
<p>导航栏字不一样多，不要设宽度，而是用padding挤开</p>
<p>量高度的时候不要量边框</p>
<h3 id="5css属性书写顺序">5.<code>css</code>属性书写顺序</h3>
<figure data-type="image" tabindex="287"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1582698631518.png" alt="1582698631518" loading="lazy"></figure>
<h3 id="6子盒子和父盒子子盒子大于父盒子">6.子盒子和父盒子（子盒子大于父盒子）</h3>
<p>子盒子是可以大于父盒子的</p>
<h3 id="7-网页布局总结">7.  网页布局总结</h3>
<p>一个完整的网页，有标准流 、 浮动 、 定位 一起完成布局的。每个都有自己的专门用法。</p>
<h4 id="1-标准流">1). 标准流</h4>
<p>可以让盒子上下排列 或者 左右排列的</p>
<h4 id="2-浮动">2). 浮动</h4>
<p>可以让多个块级元素一行显示  或者 左右对齐盒子   浮动的盒子就是按照顺序左右排列</p>
<h4 id="3-定位">3). 定位</h4>
<p>定位最大的特点是有层叠的概念，就是可以让多个盒子 前后 叠压来显示。 但是每个盒子需要测量数值。</p>
<h3 id="8-字体图标">8. 字体图标</h3>
<h4 id="1-字体图标优点">1.  字体图标优点</h4>
<pre><code>可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..
但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...
本身体积更小，但携带的信息并没有削减。
几乎支持所有的浏览器
移动端设备必备良药...
</code></pre>
<h4 id="2-字体图标使用流程">2.   字体图标使用流程</h4>
<p>总体来说，字体图标按照如下流程：</p>
<figure data-type="image" tabindex="288"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583149842507.png" alt="1583149842507" loading="lazy"></figure>
<h4 id="3-设计字体图标">3. 设计字体图标</h4>
<p>假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标， 比如下图：</p>
<figure data-type="image" tabindex="289"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583149860808.png" alt="1583149860808" loading="lazy"></figure>
<p>之后保存为svg格式，然后给我们前端人员就好了。</p>
<p>其实第一步，我们不需要关心，只需要给我们这些图标就可以了，如果图标是大众的，网上本来就有的，可以直接跳过第一步，进入第三步。</p>
<h4 id="4-上传生成字体包">4. 上传生成字体包</h4>
<p>当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。</p>
<p>​    推荐网站： http://icomoon.io</p>
<ul>
<li>icomoon字库</li>
</ul>
<p>IcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。</p>
<ul>
<li>阿里icon font字库</li>
</ul>
<p>http://www.iconfont.cn/</p>
<p>这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！</p>
<h4 id="5-下载兼容字体包">5. 下载兼容字体包</h4>
<p>刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了</p>
<p>当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。</p>
<h4 id="6-字体引入到html">6. 字体引入到HTML</h4>
<p>1.首先把 fonts文件夹放入我们 根目录下 。</p>
<ol start="2">
<li>
<p>html标签内里面添加结构</p>
<figure data-type="image" tabindex="290"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1583150000183.png" alt="1583150000183" loading="lazy"></figure>
<pre><code class="language-html">&lt;span&gt;&lt;/span&gt; 
</code></pre>
</li>
<li></li>
<li>
<h5 id="3-在样式里面声明字体-告诉别人我们自己定义的字体一定注意字体文件路径的问题">3. 在样式里面声明字体： 告诉别人我们自己定义的字体(一定注意字体文件路径的问题)</h5>
<pre><code class="language-css">@font-face {
  font-family: 'icomoon';
  src:  url('fonts/icomoon.eot?7kkyc2');
  src:  url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'),
    url('fonts/icomoon.ttf?7kkyc2') format('truetype'),
    url('fonts/icomoon.woff?7kkyc2') format('woff'),
    url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg');
  font-weight: normal;
  font-style: normal;
}
</code></pre>
<h5 id="4-给盒子使用字体">4. 给盒子使用字体</h5>
<pre><code class="language-css">span {
		font-family: &quot;icomoon&quot;;
	}
</code></pre>
</li>
</ol>
<h4 id="7-追加字体图标">7. 追加字体图标</h4>
<p>如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标，但是原来的不能删除，继续使用，此时我们需要这样做</p>
<p>把压缩包里面的selection.json 从新上传，然后，选中自己想要新的图标，从新下载压缩包，替换原来文件即可。</p>
<h1 id="开发项目实战">开发项目实战</h1>
<h2 id="1学成在线案例">1.学成在线案例</h2>
<h3 id="11-准备素材">1.1  准备素材</h3>
<h3 id="12-项目准备工作">1.2  项目准备工作</h3>
<p>欲先善其事,必先利其器。先把我们的前期准备 工作做好，我们本次采取结构与样式相分 离思想。<br>
1.创建根目录文件夹(用于存放我们这个页面的相关内容)</p>
<ol start="2">
<li>根目录内新建images文件夹用于保存图片。</li>
<li>根目录内新建<code>index.html</code>首页<code>html</code>文件(以后我们的网站首页统-规定为<code>index.html</code>)</li>
<li>根目录内新建style.css样式文件。我们本次采用外链样式表。</li>
<li>将样式引入到我们HTML页面文件中。</li>
<li>样式表写入清除内外边距样式，来检测样式表是否引入成功。</li>
</ol>
<h3 id="13布局流程">1.3布局流程</h3>
<p>为了提高网页制作的效率，布局时通常有以下的布局流程，具体如下:<br>
1、必须确定页面的版心(可视区)，我们测量可得知。<br>
2、分析页面中的<mark>行模块</mark>，以及每个行模块中的列模块。实页面布局，就是一行行罗列而成<br>
3、制作HTML结构。 我们还是遵循，先有结构，后有样式的原则。结构永远最重要。<br>
4、然后开始运用盒子模型的原理，通过DIV+<code>CSS</code>布 局来控制网页的各个模块。</p>
<h2 id="2品优购-案例-202032-315">2.品优购 案例 2020.3.2-3.15</h2>
<h2 id="3-携程网首页-202048-420">3. 携程网首页  2020.4.8-4.20</h2>
<h4 id="1-背景线性渐变">1. 背景线性渐变</h4>
<p>语法1</p>
<figure data-type="image" tabindex="291"><img src="https://ww13606467972.github.io/mylove.github.io//post-images/1587347104641.png" alt="1587347104641" loading="lazy"></figure>
<p>背景渐变必须添加浏览器私有前缀，起始方向可以是:方位名词或者度数如果省略默认就是top</p>
<h4 id="2-监听过渡完成事件">2. 监听过渡完成事件</h4>
<p>transitionend</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://ww13606467972.github.io/mylove.github.io/post/lian-ai-ri-ji/">
                  <h3 class="post-title">
                    恋爱日记
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.min.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
